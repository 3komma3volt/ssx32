CCS PCH C Compiler, Version 4.114, 93460303               03-Oct-11 21:08

               Filename: d:\projects\pic\ssx32\main.lst

               ROM used: 15508 bytes (24%)
                         Largest free fragment is 50024
               RAM used: 1375 (35%) at main() level
                         1477 (38%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   3C14
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   0174
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... /* 
....................           file: main.c 
....................        project: SSX32 
.................... 	   version: 1.1 
....................               : Open source 32/16/8 channel serial servo controller 
.................... 			  : using a daisy chain protocol 
....................    description: Main source file 
....................    written by : Michael Bradley 
....................  
.................... 	       PIC: 18F46K20 (SSX32) and PIC18F26K20 (SSX16 and SSX8) 
.................... 	       IDE: Programers Notepad 
.................... 	  compiler: CCS C v 4.106 
....................        crystal: none (internal rc) 
....................  
....................    Changelog: 
.................... 	  09/17/11 Created 32/16/8 ch versions and added addressing 
.................... 	  02/25/11 Added sin mode, and #include <math.h> 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
....................  
.................... #define _BUILD_VERSION "v1.1" 
....................  
.................... // **** SELECT PRODUCT HERE 8/16/32 **** 
.................... // this is is for the conditional compiling! 
....................  
.................... #define SSX32 
.................... //#define SSX16 
.................... //#define SSX8 
....................  
....................  
....................  
.................... //#define DEBUG_MSG 1 
.................... //#define DEBUG_INPUT 1 
.................... //#define DEBUG_PRESET 1 
.................... //#define DEBUG_FRAMES 1 
.................... //#define DEBUG_ECHO 1 
....................  
.................... #include "main.h" 
.................... /* 
....................           file: main.h 
....................        project: SSX32  
....................    description: selects correct pic device (header files) to use 
....................  
....................    Changelog: 
.................... 		09/17/11	Replaced original main.h file with this, and made 
.................... 					each device, fuse, etc... its own pic-xxxx.h file 
....................  
....................  
.................... */ 
....................  
.................... #ifdef SSX32 
.................... 	#include "pic-ssx32.h" 
.................... /* 
....................           file: pic-ssx32.h 
....................        project: SSX32  
....................    description: pic device info for ssx32 model 
....................  
....................    Changelog: 
.................... 	  09/17/11 This file moved from main.h 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
.................... #include <18F46K20.h> 
.................... //////// Standard Header file for the PIC18F46K20 device //////////////// 
.................... #device PIC18F46K20 
.................... #list 
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC_IO                 //Internal RC Osc, no CLKOUT 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... //#FUSES BORV18 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NODELAYINTOSC          
.................... #use delay(clock=64000000) 
*
00128:  MOVLW  05
0012A:  MOVWF  FEA
0012C:  MOVLW  C3
0012E:  MOVWF  FE9
00130:  MOVF   FEF,W
00132:  BZ    0150
00134:  MOVLW  14
00136:  MOVWF  01
00138:  CLRF   00
0013A:  DECFSZ 00,F
0013C:  BRA    013A
0013E:  DECFSZ 01,F
00140:  BRA    0138
00142:  MOVLW  BF
00144:  MOVWF  00
00146:  DECFSZ 00,F
00148:  BRA    0146
0014A:  BRA    014C
0014C:  DECFSZ FEF,F
0014E:  BRA    0134
00150:  RETLW  00
....................  
....................  
.................... 	#endif 
....................  
.................... #ifdef SSX16 
.................... 	#include "pic-ssx16.h" 
.................... 	#endif 
....................  
.................... #ifdef SSX8 
.................... 	#include "pic-ssx8.h" 
.................... 	#endif 
....................  
....................  
.................... #use rs232(baud=9600, bits=8, parity=n, stop=1, xmit=PIN_C6, rcv=PIN_C7, stream=ttls0) 
.................... #use rs232(baud=9600, bits=8, parity=n, stop=1, xmit=PIN_B7, rcv=PIN_B7, stream=debug) 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
01C14:  MOVLB  5
01C16:  MOVFF  576,FE9
01C1A:  MOVFF  577,FEA
01C1E:  MOVFF  FEF,57A
01C22:  MOVFF  579,03
01C26:  MOVFF  578,FE9
01C2A:  MOVFF  579,FEA
01C2E:  MOVF   FEF,W
01C30:  SUBWF  x7A,W
01C32:  BNZ   1C5E
....................       if (*s1 == '\0') 
01C34:  MOVFF  577,03
01C38:  MOVFF  576,FE9
01C3C:  MOVFF  03,FEA
01C40:  MOVF   FEF,F
01C42:  BNZ   1C4A
....................          return(0); 
01C44:  MOVLW  00
01C46:  MOVWF  01
01C48:  BRA    1C88
01C4A:  MOVFF  577,03
01C4E:  MOVF   x76,W
01C50:  INCF   x76,F
01C52:  BTFSC  FD8.2
01C54:  INCF   x77,F
01C56:  INCF   x78,F
01C58:  BTFSC  FD8.2
01C5A:  INCF   x79,F
01C5C:  BRA    1C16
....................    return((*s1 < *s2) ? -1: 1); 
01C5E:  MOVFF  577,03
01C62:  MOVFF  576,FE9
01C66:  MOVFF  577,FEA
01C6A:  MOVFF  FEF,57A
01C6E:  MOVFF  579,03
01C72:  MOVFF  578,FE9
01C76:  MOVFF  579,FEA
01C7A:  MOVF   FEF,W
01C7C:  SUBWF  x7A,W
01C7E:  BC    1C84
01C80:  MOVLW  FF
01C82:  BRA    1C86
01C84:  MOVLW  01
01C86:  MOVWF  01
.................... } 
01C88:  MOVLB  0
01C8A:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
01D02:  MOVLB  5
01D04:  CLRF   x6A
....................    sign = 0; 
01D06:  CLRF   x68
....................    base = 10; 
01D08:  MOVLW  0A
01D0A:  MOVWF  x69
....................    result = 0; 
01D0C:  CLRF   x67
....................  
....................    if (!s) 
01D0E:  MOVF   x65,W
01D10:  IORWF  x66,W
01D12:  BNZ   1D1A
....................       return 0; 
01D14:  MOVLW  00
01D16:  MOVWF  01
01D18:  BRA    1EA0
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
01D1A:  MOVF   x6A,W
01D1C:  INCF   x6A,F
01D1E:  CLRF   03
01D20:  ADDWF  x65,W
01D22:  MOVWF  FE9
01D24:  MOVF   x66,W
01D26:  ADDWFC 03,W
01D28:  MOVWF  FEA
01D2A:  MOVFF  FEF,56B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
01D2E:  MOVF   x6B,W
01D30:  SUBLW  2D
01D32:  BNZ   1D4E
....................    { 
....................       sign = 1;         // Set the sign to negative 
01D34:  MOVLW  01
01D36:  MOVWF  x68
....................       c = s[index++]; 
01D38:  MOVF   x6A,W
01D3A:  INCF   x6A,F
01D3C:  CLRF   03
01D3E:  ADDWF  x65,W
01D40:  MOVWF  FE9
01D42:  MOVF   x66,W
01D44:  ADDWFC 03,W
01D46:  MOVWF  FEA
01D48:  MOVFF  FEF,56B
....................    } 
....................    else if (c == '+') 
01D4C:  BRA    1D68
01D4E:  MOVF   x6B,W
01D50:  SUBLW  2B
01D52:  BNZ   1D68
....................    { 
....................       c = s[index++]; 
01D54:  MOVF   x6A,W
01D56:  INCF   x6A,F
01D58:  CLRF   03
01D5A:  ADDWF  x65,W
01D5C:  MOVWF  FE9
01D5E:  MOVF   x66,W
01D60:  ADDWFC 03,W
01D62:  MOVWF  FEA
01D64:  MOVFF  FEF,56B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
01D68:  MOVF   x6B,W
01D6A:  SUBLW  2F
01D6C:  BTFSC  FD8.0
01D6E:  BRA    1E90
01D70:  MOVF   x6B,W
01D72:  SUBLW  39
01D74:  BTFSS  FD8.0
01D76:  BRA    1E90
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
01D78:  MOVF   x6B,W
01D7A:  SUBLW  30
01D7C:  BNZ   1DC0
01D7E:  CLRF   03
01D80:  MOVF   x6A,W
01D82:  ADDWF  x65,W
01D84:  MOVWF  FE9
01D86:  MOVF   x66,W
01D88:  ADDWFC 03,W
01D8A:  MOVWF  FEA
01D8C:  MOVF   FEF,W
01D8E:  SUBLW  78
01D90:  BZ    1DA6
01D92:  CLRF   03
01D94:  MOVF   x6A,W
01D96:  ADDWF  x65,W
01D98:  MOVWF  FE9
01D9A:  MOVF   x66,W
01D9C:  ADDWFC 03,W
01D9E:  MOVWF  FEA
01DA0:  MOVF   FEF,W
01DA2:  SUBLW  58
01DA4:  BNZ   1DC0
....................       { 
....................          base = 16; 
01DA6:  MOVLW  10
01DA8:  MOVWF  x69
....................          index++; 
01DAA:  INCF   x6A,F
....................          c = s[index++]; 
01DAC:  MOVF   x6A,W
01DAE:  INCF   x6A,F
01DB0:  CLRF   03
01DB2:  ADDWF  x65,W
01DB4:  MOVWF  FE9
01DB6:  MOVF   x66,W
01DB8:  ADDWFC 03,W
01DBA:  MOVWF  FEA
01DBC:  MOVFF  FEF,56B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
01DC0:  MOVF   x69,W
01DC2:  SUBLW  0A
01DC4:  BNZ   1E00
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
01DC6:  MOVF   x6B,W
01DC8:  SUBLW  2F
01DCA:  BC    1DFE
01DCC:  MOVF   x6B,W
01DCE:  SUBLW  39
01DD0:  BNC   1DFE
....................             result = 10*result + (c - '0'); 
01DD2:  MOVLW  0A
01DD4:  MOVWF  x6C
01DD6:  MOVFF  567,56D
01DDA:  MOVLB  0
01DDC:  BRA    1CB2
01DDE:  MOVLW  30
01DE0:  MOVLB  5
01DE2:  SUBWF  x6B,W
01DE4:  ADDWF  01,W
01DE6:  MOVWF  x67
....................             c = s[index++]; 
01DE8:  MOVF   x6A,W
01DEA:  INCF   x6A,F
01DEC:  CLRF   03
01DEE:  ADDWF  x65,W
01DF0:  MOVWF  FE9
01DF2:  MOVF   x66,W
01DF4:  ADDWFC 03,W
01DF6:  MOVWF  FEA
01DF8:  MOVFF  FEF,56B
....................          } 
01DFC:  BRA    1DC6
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
01DFE:  BRA    1E90
01E00:  MOVF   x69,W
01E02:  SUBLW  10
01E04:  BNZ   1E90
....................       { 
....................          c = toupper(c); 
01E06:  MOVF   x6B,W
01E08:  SUBLW  60
01E0A:  BC    1E18
01E0C:  MOVF   x6B,W
01E0E:  SUBLW  7A
01E10:  BNC   1E18
01E12:  MOVF   x6B,W
01E14:  ANDLW  DF
01E16:  BRA    1E1A
01E18:  MOVF   x6B,W
01E1A:  MOVWF  x6B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
01E1C:  MOVF   x6B,W
01E1E:  SUBLW  2F
01E20:  BC    1E28
01E22:  MOVF   x6B,W
01E24:  SUBLW  39
01E26:  BC    1E34
01E28:  MOVF   x6B,W
01E2A:  SUBLW  40
01E2C:  BC    1E90
01E2E:  MOVF   x6B,W
01E30:  SUBLW  46
01E32:  BNC   1E90
....................             if (c >= '0' && c <= '9') 
01E34:  MOVF   x6B,W
01E36:  SUBLW  2F
01E38:  BC    1E52
01E3A:  MOVF   x6B,W
01E3C:  SUBLW  39
01E3E:  BNC   1E52
....................                result = (result << 4) + (c - '0'); 
01E40:  SWAPF  x67,W
01E42:  MOVWF  x6C
01E44:  MOVLW  F0
01E46:  ANDWF  x6C,F
01E48:  MOVLW  30
01E4A:  SUBWF  x6B,W
01E4C:  ADDWF  x6C,W
01E4E:  MOVWF  x67
....................             else 
01E50:  BRA    1E64
....................                result = (result << 4) + (c - 'A' + 10); 
01E52:  SWAPF  x67,W
01E54:  MOVWF  x6C
01E56:  MOVLW  F0
01E58:  ANDWF  x6C,F
01E5A:  MOVLW  41
01E5C:  SUBWF  x6B,W
01E5E:  ADDLW  0A
01E60:  ADDWF  x6C,W
01E62:  MOVWF  x67
....................  
....................             c = s[index++]; 
01E64:  MOVF   x6A,W
01E66:  INCF   x6A,F
01E68:  CLRF   03
01E6A:  ADDWF  x65,W
01E6C:  MOVWF  FE9
01E6E:  MOVF   x66,W
01E70:  ADDWFC 03,W
01E72:  MOVWF  FEA
01E74:  MOVFF  FEF,56B
....................             c = toupper(c); 
01E78:  MOVF   x6B,W
01E7A:  SUBLW  60
01E7C:  BC    1E8A
01E7E:  MOVF   x6B,W
01E80:  SUBLW  7A
01E82:  BNC   1E8A
01E84:  MOVF   x6B,W
01E86:  ANDLW  DF
01E88:  BRA    1E8C
01E8A:  MOVF   x6B,W
01E8C:  MOVWF  x6B
....................          } 
01E8E:  BRA    1E1C
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
01E90:  DECFSZ x68,W
01E92:  BRA    1E9C
01E94:  MOVF   x69,W
01E96:  SUBLW  0A
01E98:  BNZ   1E9C
....................        result = -result; 
01E9A:  NEGF   x67
....................  
....................    return(result); 
01E9C:  MOVFF  567,01
.................... } 
01EA0:  MOVLB  0
01EA2:  GOTO   387A (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0202A:  MOVLB  5
0202C:  CLRF   x7A
....................    sign = 0; 
0202E:  CLRF   x78
....................    base = 10; 
02030:  MOVLW  0A
02032:  MOVWF  x79
....................    result = 0; 
02034:  CLRF   x77
02036:  CLRF   x76
....................  
....................    if (!s) 
02038:  MOVF   x74,W
0203A:  IORWF  x75,W
0203C:  BNZ   2046
....................       return 0; 
0203E:  MOVLW  00
02040:  MOVWF  01
02042:  MOVWF  02
02044:  BRA    2216
....................    c = s[index++]; 
02046:  MOVF   x7A,W
02048:  INCF   x7A,F
0204A:  CLRF   03
0204C:  ADDWF  x74,W
0204E:  MOVWF  FE9
02050:  MOVF   x75,W
02052:  ADDWFC 03,W
02054:  MOVWF  FEA
02056:  MOVFF  FEF,57B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0205A:  MOVF   x7B,W
0205C:  SUBLW  2D
0205E:  BNZ   207A
....................    { 
....................       sign = 1;         // Set the sign to negative 
02060:  MOVLW  01
02062:  MOVWF  x78
....................       c = s[index++]; 
02064:  MOVF   x7A,W
02066:  INCF   x7A,F
02068:  CLRF   03
0206A:  ADDWF  x74,W
0206C:  MOVWF  FE9
0206E:  MOVF   x75,W
02070:  ADDWFC 03,W
02072:  MOVWF  FEA
02074:  MOVFF  FEF,57B
....................    } 
....................    else if (c == '+') 
02078:  BRA    2094
0207A:  MOVF   x7B,W
0207C:  SUBLW  2B
0207E:  BNZ   2094
....................    { 
....................       c = s[index++]; 
02080:  MOVF   x7A,W
02082:  INCF   x7A,F
02084:  CLRF   03
02086:  ADDWF  x74,W
02088:  MOVWF  FE9
0208A:  MOVF   x75,W
0208C:  ADDWFC 03,W
0208E:  MOVWF  FEA
02090:  MOVFF  FEF,57B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
02094:  MOVF   x7B,W
02096:  SUBLW  2F
02098:  BTFSC  FD8.0
0209A:  BRA    21FA
0209C:  MOVF   x7B,W
0209E:  SUBLW  39
020A0:  BTFSS  FD8.0
020A2:  BRA    21FA
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
020A4:  MOVF   x7B,W
020A6:  SUBLW  30
020A8:  BNZ   20EC
020AA:  CLRF   03
020AC:  MOVF   x7A,W
020AE:  ADDWF  x74,W
020B0:  MOVWF  FE9
020B2:  MOVF   x75,W
020B4:  ADDWFC 03,W
020B6:  MOVWF  FEA
020B8:  MOVF   FEF,W
020BA:  SUBLW  78
020BC:  BZ    20D2
020BE:  CLRF   03
020C0:  MOVF   x7A,W
020C2:  ADDWF  x74,W
020C4:  MOVWF  FE9
020C6:  MOVF   x75,W
020C8:  ADDWFC 03,W
020CA:  MOVWF  FEA
020CC:  MOVF   FEF,W
020CE:  SUBLW  58
020D0:  BNZ   20EC
....................       { 
....................          base = 16; 
020D2:  MOVLW  10
020D4:  MOVWF  x79
....................          index++; 
020D6:  INCF   x7A,F
....................          c = s[index++]; 
020D8:  MOVF   x7A,W
020DA:  INCF   x7A,F
020DC:  CLRF   03
020DE:  ADDWF  x74,W
020E0:  MOVWF  FE9
020E2:  MOVF   x75,W
020E4:  ADDWFC 03,W
020E6:  MOVWF  FEA
020E8:  MOVFF  FEF,57B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
020EC:  MOVF   x79,W
020EE:  SUBLW  0A
020F0:  BNZ   2138
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
020F2:  MOVF   x7B,W
020F4:  SUBLW  2F
020F6:  BC    2136
020F8:  MOVF   x7B,W
020FA:  SUBLW  39
020FC:  BNC   2136
....................             result = 10*result + (c - '0'); 
020FE:  CLRF   x7D
02100:  MOVLW  0A
02102:  MOVWF  x7C
02104:  MOVFF  577,57F
02108:  MOVFF  576,57E
0210C:  MOVLB  0
0210E:  BRA    1FD4
02110:  MOVLW  30
02112:  MOVLB  5
02114:  SUBWF  x7B,W
02116:  ADDWF  01,W
02118:  MOVWF  x76
0211A:  MOVLW  00
0211C:  ADDWFC 02,W
0211E:  MOVWF  x77
....................             c = s[index++]; 
02120:  MOVF   x7A,W
02122:  INCF   x7A,F
02124:  CLRF   03
02126:  ADDWF  x74,W
02128:  MOVWF  FE9
0212A:  MOVF   x75,W
0212C:  ADDWFC 03,W
0212E:  MOVWF  FEA
02130:  MOVFF  FEF,57B
....................          } 
02134:  BRA    20F2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
02136:  BRA    21FA
02138:  MOVF   x79,W
0213A:  SUBLW  10
0213C:  BNZ   21FA
....................       { 
....................          c = toupper(c); 
0213E:  MOVF   x7B,W
02140:  SUBLW  60
02142:  BC    2150
02144:  MOVF   x7B,W
02146:  SUBLW  7A
02148:  BNC   2150
0214A:  MOVF   x7B,W
0214C:  ANDLW  DF
0214E:  BRA    2152
02150:  MOVF   x7B,W
02152:  MOVWF  x7B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
02154:  MOVF   x7B,W
02156:  SUBLW  2F
02158:  BC    2160
0215A:  MOVF   x7B,W
0215C:  SUBLW  39
0215E:  BC    216C
02160:  MOVF   x7B,W
02162:  SUBLW  40
02164:  BC    21FA
02166:  MOVF   x7B,W
02168:  SUBLW  46
0216A:  BNC   21FA
....................             if (c >= '0' && c <= '9') 
0216C:  MOVF   x7B,W
0216E:  SUBLW  2F
02170:  BC    21A4
02172:  MOVF   x7B,W
02174:  SUBLW  39
02176:  BNC   21A4
....................                result = (result << 4) + (c - '0'); 
02178:  RLCF   x76,W
0217A:  MOVWF  x7C
0217C:  RLCF   x77,W
0217E:  MOVWF  x7D
02180:  RLCF   x7C,F
02182:  RLCF   x7D,F
02184:  RLCF   x7C,F
02186:  RLCF   x7D,F
02188:  RLCF   x7C,F
0218A:  RLCF   x7D,F
0218C:  MOVLW  F0
0218E:  ANDWF  x7C,F
02190:  MOVLW  30
02192:  SUBWF  x7B,W
02194:  ADDWF  x7C,W
02196:  MOVWF  01
02198:  MOVLW  00
0219A:  ADDWFC x7D,W
0219C:  MOVFF  01,576
021A0:  MOVWF  x77
....................             else 
021A2:  BRA    21D0
....................                result = (result << 4) + (c - 'A' + 10); 
021A4:  RLCF   x76,W
021A6:  MOVWF  x7C
021A8:  RLCF   x77,W
021AA:  MOVWF  x7D
021AC:  RLCF   x7C,F
021AE:  RLCF   x7D,F
021B0:  RLCF   x7C,F
021B2:  RLCF   x7D,F
021B4:  RLCF   x7C,F
021B6:  RLCF   x7D,F
021B8:  MOVLW  F0
021BA:  ANDWF  x7C,F
021BC:  MOVLW  41
021BE:  SUBWF  x7B,W
021C0:  ADDLW  0A
021C2:  ADDWF  x7C,W
021C4:  MOVWF  01
021C6:  MOVLW  00
021C8:  ADDWFC x7D,W
021CA:  MOVFF  01,576
021CE:  MOVWF  x77
....................  
....................             c = s[index++];c = toupper(c); 
021D0:  MOVF   x7A,W
021D2:  INCF   x7A,F
021D4:  CLRF   03
021D6:  ADDWF  x74,W
021D8:  MOVWF  FE9
021DA:  MOVF   x75,W
021DC:  ADDWFC 03,W
021DE:  MOVWF  FEA
021E0:  MOVF   FEF,W
021E2:  MOVWF  x7B
021E4:  SUBLW  60
021E6:  BC    21F4
021E8:  MOVF   x7B,W
021EA:  SUBLW  7A
021EC:  BNC   21F4
021EE:  MOVF   x7B,W
021F0:  ANDLW  DF
021F2:  BRA    21F6
021F4:  MOVF   x7B,W
021F6:  MOVWF  x7B
....................          } 
021F8:  BRA    2154
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
021FA:  MOVF   x79,W
021FC:  SUBLW  0A
021FE:  BNZ   220E
02200:  DECFSZ x78,W
02202:  BRA    220E
....................       result = -result; 
02204:  COMF   x76,F
02206:  COMF   x77,F
02208:  INCF   x76,F
0220A:  BTFSC  FD8.2
0220C:  INCF   x77,F
....................  
....................    return(result); 
0220E:  MOVFF  576,01
02212:  MOVFF  577,02
.................... } 
02216:  MOVLB  0
02218:  GOTO   2D14 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
0282A:  MOVLB  5
0282C:  CLRF   x8F
0282E:  CLRF   x8E
02830:  CLRF   x8D
02832:  MOVLW  7F
02834:  MOVWF  x8C
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
02836:  MOVLW  7E
02838:  MOVWF  x96
0283A:  MOVLW  80
0283C:  MOVWF  x97
0283E:  CLRF   x98
02840:  CLRF   x99
02842:  MOVLW  7A
02844:  MOVWF  x9A
02846:  MOVLW  2A
02848:  MOVWF  x9B
0284A:  MOVLW  AA
0284C:  MOVWF  x9C
0284E:  MOVLW  AB
02850:  MOVWF  x9D
02852:  MOVLW  75
02854:  MOVWF  x9E
02856:  MOVLW  B6
02858:  MOVWF  x9F
0285A:  MOVLW  0B
0285C:  MOVWF  xA0
0285E:  MOVLW  61
02860:  MOVWF  xA1
02862:  MOVLW  6F
02864:  MOVWF  xA2
02866:  MOVLW  50
02868:  MOVWF  xA3
0286A:  MOVLW  0D
0286C:  MOVWF  xA4
0286E:  MOVLW  01
02870:  MOVWF  xA5
02872:  MOVLW  69
02874:  MOVWF  xA6
02876:  MOVLW  93
02878:  MOVWF  xA7
0287A:  MOVLW  F2
0287C:  MOVWF  xA8
0287E:  MOVLW  7E
02880:  MOVWF  xA9
02882:  MOVLW  62
02884:  MOVWF  xAA
02886:  MOVLW  0F
02888:  MOVWF  xAB
0288A:  MOVLW  76
0288C:  MOVWF  xAC
0288E:  MOVLW  AE
02890:  MOVWF  xAD
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
02892:  MOVFF  583,5B1
02896:  MOVFF  582,5B0
0289A:  MOVFF  581,5AF
0289E:  MOVFF  580,5AE
028A2:  CLRF   xB5
028A4:  CLRF   xB4
028A6:  CLRF   xB3
028A8:  CLRF   xB2
028AA:  MOVLB  0
028AC:  BRA    2646
028AE:  BNC   28B8
028B0:  MOVLB  5
028B2:  MOVF   x81,W
028B4:  XORLW  80
028B6:  MOVWF  x81
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
028B8:  MOVFF  583,5B5
028BC:  MOVFF  582,5B4
028C0:  MOVFF  581,5B3
028C4:  MOVFF  580,5B2
028C8:  MOVLW  83
028CA:  MOVLB  5
028CC:  MOVWF  xB9
028CE:  MOVLW  F9
028D0:  MOVWF  xB8
028D2:  MOVLW  22
028D4:  MOVWF  xB7
028D6:  MOVLW  7E
028D8:  MOVWF  xB6
028DA:  MOVLB  0
028DC:  RCALL  26C2
028DE:  MOVFF  03,5B1
028E2:  MOVFF  02,5B0
028E6:  MOVFF  01,5AF
028EA:  MOVFF  00,5AE
028EE:  RCALL  27B8
028F0:  MOVFF  01,590
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
028F4:  MOVFF  583,5B5
028F8:  MOVFF  582,5B4
028FC:  MOVFF  581,5B3
02900:  MOVFF  580,5B2
02904:  MOVLW  83
02906:  MOVLB  5
02908:  MOVWF  xB9
0290A:  MOVLW  F9
0290C:  MOVWF  xB8
0290E:  MOVLW  22
02910:  MOVWF  xB7
02912:  MOVLW  7E
02914:  MOVWF  xB6
02916:  MOVLB  0
02918:  RCALL  26C2
0291A:  MOVFF  00,5AE
0291E:  MOVFF  01,5AF
02922:  MOVFF  02,5B0
02926:  MOVFF  03,5B1
0292A:  MOVLB  5
0292C:  CLRF   xB3
0292E:  MOVFF  590,5B2
02932:  MOVLB  0
02934:  RCALL  27F4
02936:  BSF    FD8.1
02938:  MOVFF  5B1,5B5
0293C:  MOVFF  5B0,5B4
02940:  MOVFF  5AF,5B3
02944:  MOVFF  5AE,5B2
02948:  MOVFF  03,5B9
0294C:  MOVFF  02,5B8
02950:  MOVFF  01,5B7
02954:  MOVFF  00,5B6
02958:  RCALL  23CE
0295A:  MOVFF  03,595
0295E:  MOVFF  02,594
02962:  MOVFF  01,593
02966:  MOVFF  00,592
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0296A:  MOVLW  03
0296C:  MOVLB  5
0296E:  ANDWF  x90,F
....................  
....................    if (quad == 0 || quad == 2) 
02970:  MOVF   x90,F
02972:  BZ    297A
02974:  MOVF   x90,W
02976:  SUBLW  02
02978:  BNZ   29B2
....................       t = frac * PI_DIV_BY_TWO; 
0297A:  MOVFF  595,5B5
0297E:  MOVFF  594,5B4
02982:  MOVFF  593,5B3
02986:  MOVFF  592,5B2
0298A:  MOVLW  DB
0298C:  MOVWF  xB9
0298E:  MOVLW  0F
02990:  MOVWF  xB8
02992:  MOVLW  49
02994:  MOVWF  xB7
02996:  MOVLW  7F
02998:  MOVWF  xB6
0299A:  MOVLB  0
0299C:  RCALL  26C2
0299E:  MOVFF  03,58B
029A2:  MOVFF  02,58A
029A6:  MOVFF  01,589
029AA:  MOVFF  00,588
....................    else if (quad == 1) 
029AE:  BRA    2A86
029B0:  MOVLB  5
029B2:  DECFSZ x90,W
029B4:  BRA    2A20
....................       t = (1-frac) * PI_DIV_BY_TWO; 
029B6:  BSF    FD8.1
029B8:  CLRF   xB5
029BA:  CLRF   xB4
029BC:  CLRF   xB3
029BE:  MOVLW  7F
029C0:  MOVWF  xB2
029C2:  MOVFF  595,5B9
029C6:  MOVFF  594,5B8
029CA:  MOVFF  593,5B7
029CE:  MOVFF  592,5B6
029D2:  MOVLB  0
029D4:  RCALL  23CE
029D6:  MOVFF  00,5AE
029DA:  MOVFF  01,5AF
029DE:  MOVFF  02,5B0
029E2:  MOVFF  03,5B1
029E6:  MOVFF  03,5B5
029EA:  MOVFF  02,5B4
029EE:  MOVFF  01,5B3
029F2:  MOVFF  00,5B2
029F6:  MOVLW  DB
029F8:  MOVLB  5
029FA:  MOVWF  xB9
029FC:  MOVLW  0F
029FE:  MOVWF  xB8
02A00:  MOVLW  49
02A02:  MOVWF  xB7
02A04:  MOVLW  7F
02A06:  MOVWF  xB6
02A08:  MOVLB  0
02A0A:  RCALL  26C2
02A0C:  MOVFF  03,58B
02A10:  MOVFF  02,58A
02A14:  MOVFF  01,589
02A18:  MOVFF  00,588
....................    else // should be 3 
02A1C:  BRA    2A86
02A1E:  MOVLB  5
....................       t = (frac-1) * PI_DIV_BY_TWO; 
02A20:  BSF    FD8.1
02A22:  MOVFF  595,5B5
02A26:  MOVFF  594,5B4
02A2A:  MOVFF  593,5B3
02A2E:  MOVFF  592,5B2
02A32:  CLRF   xB9
02A34:  CLRF   xB8
02A36:  CLRF   xB7
02A38:  MOVLW  7F
02A3A:  MOVWF  xB6
02A3C:  MOVLB  0
02A3E:  RCALL  23CE
02A40:  MOVFF  00,5AE
02A44:  MOVFF  01,5AF
02A48:  MOVFF  02,5B0
02A4C:  MOVFF  03,5B1
02A50:  MOVFF  03,5B5
02A54:  MOVFF  02,5B4
02A58:  MOVFF  01,5B3
02A5C:  MOVFF  00,5B2
02A60:  MOVLW  DB
02A62:  MOVLB  5
02A64:  MOVWF  xB9
02A66:  MOVLW  0F
02A68:  MOVWF  xB8
02A6A:  MOVLW  49
02A6C:  MOVWF  xB7
02A6E:  MOVLW  7F
02A70:  MOVWF  xB6
02A72:  MOVLB  0
02A74:  RCALL  26C2
02A76:  MOVFF  03,58B
02A7A:  MOVFF  02,58A
02A7E:  MOVFF  01,589
02A82:  MOVFF  00,588
....................  
....................    y = 1.0; 
02A86:  MOVLB  5
02A88:  CLRF   x87
02A8A:  CLRF   x86
02A8C:  CLRF   x85
02A8E:  MOVLW  7F
02A90:  MOVWF  x84
....................    t = t * t; 
02A92:  MOVFF  58B,5B5
02A96:  MOVFF  58A,5B4
02A9A:  MOVFF  589,5B3
02A9E:  MOVFF  588,5B2
02AA2:  MOVFF  58B,5B9
02AA6:  MOVFF  58A,5B8
02AAA:  MOVFF  589,5B7
02AAE:  MOVFF  588,5B6
02AB2:  MOVLB  0
02AB4:  RCALL  26C2
02AB6:  MOVFF  03,58B
02ABA:  MOVFF  02,58A
02ABE:  MOVFF  01,589
02AC2:  MOVFF  00,588
....................    for (i = 0; i <= 5; i++) 
02AC6:  MOVLB  5
02AC8:  CLRF   x91
02ACA:  MOVF   x91,W
02ACC:  SUBLW  05
02ACE:  BNC   2B96
....................    { 
....................       t2 = t2 * t; 
02AD0:  MOVFF  58F,5B5
02AD4:  MOVFF  58E,5B4
02AD8:  MOVFF  58D,5B3
02ADC:  MOVFF  58C,5B2
02AE0:  MOVFF  58B,5B9
02AE4:  MOVFF  58A,5B8
02AE8:  MOVFF  589,5B7
02AEC:  MOVFF  588,5B6
02AF0:  MOVLB  0
02AF2:  RCALL  26C2
02AF4:  MOVFF  03,58F
02AF8:  MOVFF  02,58E
02AFC:  MOVFF  01,58D
02B00:  MOVFF  00,58C
....................       y = y + p[i] * t2; 
02B04:  MOVLB  5
02B06:  MOVF   x91,W
02B08:  MULLW  04
02B0A:  MOVF   FF3,W
02B0C:  CLRF   03
02B0E:  ADDLW  96
02B10:  MOVWF  FE9
02B12:  MOVLW  05
02B14:  ADDWFC 03,W
02B16:  MOVWF  FEA
02B18:  MOVFF  FEF,5AE
02B1C:  MOVFF  FEC,5AF
02B20:  MOVFF  FEC,5B0
02B24:  MOVFF  FEC,5B1
02B28:  MOVFF  5B1,5B5
02B2C:  MOVFF  5B0,5B4
02B30:  MOVFF  5AF,5B3
02B34:  MOVFF  5AE,5B2
02B38:  MOVFF  58F,5B9
02B3C:  MOVFF  58E,5B8
02B40:  MOVFF  58D,5B7
02B44:  MOVFF  58C,5B6
02B48:  MOVLB  0
02B4A:  RCALL  26C2
02B4C:  MOVFF  FEA,5AF
02B50:  MOVFF  FE9,5AE
02B54:  BCF    FD8.1
02B56:  MOVFF  587,5B5
02B5A:  MOVFF  586,5B4
02B5E:  MOVFF  585,5B3
02B62:  MOVFF  584,5B2
02B66:  MOVFF  03,5B9
02B6A:  MOVFF  02,5B8
02B6E:  MOVFF  01,5B7
02B72:  MOVFF  00,5B6
02B76:  RCALL  23CE
02B78:  MOVFF  5AF,FEA
02B7C:  MOVFF  5AE,FE9
02B80:  MOVFF  03,587
02B84:  MOVFF  02,586
02B88:  MOVFF  01,585
02B8C:  MOVFF  00,584
....................    } 
02B90:  MOVLB  5
02B92:  INCF   x91,F
02B94:  BRA    2ACA
....................  
....................    if (quad == 2 || quad == 1) 
02B96:  MOVF   x90,W
02B98:  SUBLW  02
02B9A:  BZ    2BA0
02B9C:  DECFSZ x90,W
02B9E:  BRA    2BA6
....................       y = -y;  // correct sign 
02BA0:  MOVF   x85,W
02BA2:  XORLW  80
02BA4:  MOVWF  x85
....................  
....................    return (y); 
02BA6:  MOVFF  584,00
02BAA:  MOVFF  585,01
02BAE:  MOVFF  586,02
02BB2:  MOVFF  587,03
.................... } 
02BB6:  MOVLB  0
02BB8:  GOTO   2C08 (RETURN)
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
02BBC:  BSF    FD8.1
02BBE:  MOVFF  57B,5B5
02BC2:  MOVFF  57A,5B4
02BC6:  MOVFF  579,5B3
02BCA:  MOVFF  578,5B2
02BCE:  MOVLW  DB
02BD0:  MOVLB  5
02BD2:  MOVWF  xB9
02BD4:  MOVLW  0F
02BD6:  MOVWF  xB8
02BD8:  MOVLW  49
02BDA:  MOVWF  xB7
02BDC:  MOVLW  7F
02BDE:  MOVWF  xB6
02BE0:  MOVLB  0
02BE2:  CALL   23CE
02BE6:  MOVFF  00,57C
02BEA:  MOVFF  01,57D
02BEE:  MOVFF  02,57E
02BF2:  MOVFF  03,57F
02BF6:  MOVFF  03,583
02BFA:  MOVFF  02,582
02BFE:  MOVFF  01,581
02C02:  MOVFF  00,580
02C06:  BRA    282A
.................... } 
02C08:  GOTO   2EEA (RETURN)
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "defines.h" 
.................... /* 
....................           file: defines.h 
....................        project: SSX32  
....................    description: some defines 
....................     
....................    Changelog: 
.................... 	  09/17/11 Allowed adressing multiple devices with same ID 
.................... 	  01/25/11 Moved pin defs to new file (pins.h) 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
....................  
....................  
.................... // this is the @daisy ID for this project 
.................... #ifdef SSX32 
.................... 	#define DEVICE_ID		"@SSX32" 
.................... 	#define _BUILD_PROJECT "SSX32"  
.................... 	#define	MAX_SERVOS		32		// number of servos this for this controller 
.................... 	#define BANK0_S			0 
.................... 	#define BANK0_E			7 
.................... 	#define BANK1_S			8 
.................... 	#define BANK1_E			15 
.................... 	#define BANK2_S			16 
.................... 	#define BANK2_E			23 
.................... 	#define BANK3_S			24 
.................... 	#define BANK3_E			31 
.................... 	#endif 
....................  
.................... #ifdef SSX16 
.................... 	#define DEVICE_ID		"@SSX16" 
.................... 	#define _BUILD_PROJECT "SSX16"  
.................... 	#define	MAX_SERVOS		16		// number of servos this for this controller 
.................... 	#define BANK0_S			0 
.................... 	#define BANK0_E			7 
.................... 	#define BANK1_S			8 
.................... 	#define BANK1_E			15 
.................... 	#endif 
....................  
.................... #ifdef SSX8 
.................... 	#define DEVICE_ID		"@SSX8" 
.................... 	#define _BUILD_PROJECT "SSX8"  
.................... 	#define	MAX_SERVOS		8		// number of servos this for this controller 
.................... 	#define BANK0_S			0 
.................... 	#define BANK0_E			7 
.................... 	#endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #define FRAME_RATE		32000	// .5 uSec steps for frame rate. 16ms is a fast for analogs 
.................... #define MS_FRAME		16		// mSec in a frame (used to compute moves over time) 
....................  
.................... //#define FRAME_RATE		40000	// .5 uSec steps for frame rate. 16ms is a fast for analogs 
.................... //#define MS_FRAME		20		// mSec in a frame (used to compute moves over time) 
....................  
....................  
.................... #define PW_CENTER		1500	// uSec for servo center (I know, some are 1520, get over it) 
.................... #define PW_MIN			800		// default min/max 
.................... #define PW_MAX			2200 
....................  
.................... // misc defines 
.................... #define LOW				0 
.................... #define HIGH			1 
....................  
.................... #define OFF				0 
.................... #define ON				1 
....................  
.................... // mode of operation for the servos 
.................... #define MODE_OFF		0x00 
.................... #define MODE_NORMAL		0x01 
.................... #define MODE_COPY		0x02 
.................... #define MODE_MIRROR		0x03 
.................... #define MODE_FOLLOW		0x04 
....................  
....................  
.................... #define FRAME_WAIT		0x01 
.................... #define FRAME_ALLOFF	0x02 
....................  
....................  
.................... // some macros 
.................... #define mForever		for(;;) 
.................... #define mServoLoop		for (i=0; i<MAX_SERVOS; i++) 
....................  
....................  
.................... #define mOutputSXHigh(i)		output_high(servoPins[i]) 
.................... #define mOutputSXLow(i)			output_low(servoPins[i]) 
.................... #define mOutputDiscrete(i)		output_bit(servoPins[i], servo[i].discrete) 
....................  
.................... #define mBeginFrame		set_timer1(0); 
.................... #define mWaitFrame		while(get_timer1() < FRAME_RATE); 		// important ; at end of line 
....................  
....................  
.................... #define mLED(pin,s)		output_bit(pin,s) 
....................  
.................... #ifndef CMP_EQ 
....................    #define CMP_LT -1 
....................    #define CMP_EQ 0 
....................    #define CMP_GT 1 
....................    #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "_build.c" 
.................... /* 
....................           file: _build.c 
....................        project: standard include 
....................    description: Use for tracking build date and time and setting 
....................                 the output hex file name 
....................    written by : Michael Bradley 
....................  
....................    Changelog: 
.................... 		    10/03/11 Modified for use with SSX  
....................             08/31/09 This module created 
....................  
....................  
....................    USE: 
....................       // optional, these control the hex file name 
....................       #define _BUILD_PROJECT "Prj_Name"    
....................       #define _BUILD_VERSION "v1.0" 
....................  
....................       #include "_build.c" 
....................     
....................    REFERENCE: 
....................    19 bytes of ROM are used to store the build date and time 
....................    _build[] string format: "31-Aug-09 23:55:18" 
....................  
.................... */ 
....................  
....................  
.................... //const char _build[19] = {__DATE__ " " __TIME__}; 
....................  
.................... #ifdef _BUILD_PROJECT 
....................    #define _BUILD_FILE "bin/" _BUILD_PROJECT "-" _BUILD_VERSION "-" __DATE__ ".hex" 
....................    #export (file=_BUILD_FILE, HEX) 
.................... #endif 
....................  
....................  
....................  
.................... #include "pins.h" 
.................... /* 
....................           file: pins.h 
....................        project: SSX32  
....................    description: pin defines 
....................     
....................    Changelog: 
.................... 	  09/17/11 Updated for 8/16/32 chanel devices 
....................       01/25/11 This file created 
....................  
....................  
.................... */ 
....................  
....................  
.................... // power led 
.................... #ifdef SSX32 
.................... 	#define PW_LED	PIN_C5 
.................... 	#endif 
....................  
.................... #ifdef SSX16 
.................... 	#define PW_LED	PIN_C5 
.................... 	#endif 
....................  
.................... #ifdef SSX8 
.................... 	#define PW_LED	PIN_C5 
.................... 	#endif 
....................  
....................  
.................... // servo output pins 
.................... #ifdef SSX32 
.................... const int16 servoPins[MAX_SERVOS] = { 
.................... 					PIN_D4, PIN_D5, PIN_D6, PIN_D7, PIN_B0, PIN_B1, PIN_B2, PIN_B3, 
.................... 					PIN_B4, PIN_B5, PIN_B6, PIN_B7, PIN_A0, PIN_A1, PIN_A2, PIN_A3, 
.................... 					PIN_C4, PIN_D3, PIN_D2, PIN_D1, PIN_D0, PIN_C3, PIN_C2, PIN_C1, 
.................... 					PIN_C0, PIN_A6, PIN_A7, PIN_E2, PIN_E1, PIN_E0, PIN_A5, PIN_A4 
.................... 					} ; 
.................... #endif 
....................  
.................... #ifdef SSX16 
.................... const int16 servoPins[MAX_SERVOS] = { 
.................... 					PIN_A0, PIN_A1, PIN_A2, PIN_A3, PIN_A4, PIN_A5, PIN_A7, PIN_A6, 
.................... 					PIN_C0, PIN_C1, PIN_C2, PIN_C3, PIN_C4, PIN_B0, PIN_B1, PIN_B2, 
.................... 					} ; 
.................... #endif 
....................  
.................... #ifdef SSX8 
.................... const int16 servoPins[MAX_SERVOS] = { 
.................... 					PIN_A0, PIN_A1, PIN_A2, PIN_A3, PIN_A4, PIN_A5, PIN_A7, PIN_A6, 
.................... 					} ; 
.................... #endif 
....................  
.................... #include "globals.h" 
.................... /* 
....................           file: globals.h 
....................        project: SSX32  
....................    description: global variables 
....................  
....................    Changelog: 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
....................  
....................  
....................  
.................... struct strServo 
.................... { 
.................... 	int8			mode;				// current mode for this servo 
.................... 	int16			pwCurrent;			// current pw 
.................... 	int16			pwDestination;		// desired pw 
.................... 	int16			step;				// uSec step value per second 
.................... 	int8			decel;				// flag for deceleration 
.................... 	signed int16	offset;				// offset value 
.................... 	int16			home;				// home position 
.................... 	int16			min;				// min pw 
.................... 	int16			max;				// max pw 
.................... 	int8			writeOffset;		// flag if we need to write offset value 
.................... 	int8			writeHome;			// flag if we need to write home value 
.................... 	int8			writeMin;			// flag if we need to write min values 
.................... 	int8			writeMax;			// flag if we need to write min values 
.................... 	int8			master;				// used for follow or mirror 
.................... 	int8			discrete;			// discrete value, if discrete mode 
.................... 	int16			timeOut;			// used to denote when to end pw. also alows update durring frame 
.................... } ; 
....................  
....................  
.................... struct strServo	servo[MAX_SERVOS]; 
....................  
.................... int8	sorted[MAX_SERVOS];		// holds a list of servos, in order, for PW to be turned off 
....................  
.................... // these are used durring input parseing 
.................... int8	modalServo; 
.................... int16	modalTime; 
.................... int8	flagAllOff; 
.................... int8	flagSin; 
....................  
.................... #include "functions.c" 
.................... /* 
....................           file: functions.c 
....................        project: SSX32  
....................    description: misc. functions 
....................  
....................    Changelog: 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
....................  
....................  
.................... void boundsCheck(int8 s) 
.................... { 
.................... 	if ( servo[s].pwDestination < servo[s].min ) { 
*
009F6:  MOVLB  5
009F8:  CLRF   x79
009FA:  MOVFF  574,578
009FE:  CLRF   x7B
00A00:  MOVLW  18
00A02:  MOVWF  x7A
00A04:  MOVLB  0
00A06:  RCALL  0492
00A08:  MOVFF  01,575
00A0C:  MOVLW  03
00A0E:  MOVLB  5
00A10:  ADDWF  01,W
00A12:  MOVWF  01
00A14:  MOVLW  00
00A16:  ADDWFC 02,W
00A18:  MOVWF  03
00A1A:  MOVF   01,W
00A1C:  ADDLW  20
00A1E:  MOVWF  FE9
00A20:  MOVLW  00
00A22:  ADDWFC 03,W
00A24:  MOVWF  FEA
00A26:  MOVFF  FEC,576
00A2A:  MOVF   FED,F
00A2C:  MOVFF  FEF,575
00A30:  CLRF   x79
00A32:  MOVFF  574,578
00A36:  CLRF   x7B
00A38:  MOVLW  18
00A3A:  MOVWF  x7A
00A3C:  MOVLB  0
00A3E:  RCALL  0492
00A40:  MOVFF  02,578
00A44:  MOVFF  01,577
00A48:  MOVLW  0C
00A4A:  MOVLB  5
00A4C:  ADDWF  01,W
00A4E:  MOVWF  01
00A50:  MOVLW  00
00A52:  ADDWFC 02,W
00A54:  MOVWF  03
00A56:  MOVF   01,W
00A58:  ADDLW  20
00A5A:  MOVWF  FE9
00A5C:  MOVLW  00
00A5E:  ADDWFC 03,W
00A60:  MOVWF  FEA
00A62:  MOVFF  FEC,03
00A66:  MOVF   FED,F
00A68:  MOVFF  FEF,01
00A6C:  MOVF   x76,W
00A6E:  SUBWF  03,W
00A70:  BNC   0AF8
00A72:  BNZ   0A7A
00A74:  MOVF   01,W
00A76:  SUBWF  x75,W
00A78:  BC    0AF8
.................... 	  servo[s].pwDestination = servo[s].min; 
00A7A:  CLRF   x79
00A7C:  MOVFF  574,578
00A80:  CLRF   x7B
00A82:  MOVLW  18
00A84:  MOVWF  x7A
00A86:  MOVLB  0
00A88:  RCALL  0492
00A8A:  MOVFF  01,575
00A8E:  MOVLW  03
00A90:  MOVLB  5
00A92:  ADDWF  01,W
00A94:  MOVWF  01
00A96:  MOVLW  00
00A98:  ADDWFC 02,W
00A9A:  MOVWF  03
00A9C:  MOVF   01,W
00A9E:  ADDLW  20
00AA0:  MOVWF  01
00AA2:  MOVLW  00
00AA4:  ADDWFC 03,F
00AA6:  MOVFF  01,575
00AAA:  MOVFF  03,576
00AAE:  CLRF   x79
00AB0:  MOVFF  574,578
00AB4:  CLRF   x7B
00AB6:  MOVLW  18
00AB8:  MOVWF  x7A
00ABA:  MOVLB  0
00ABC:  RCALL  0492
00ABE:  MOVFF  01,577
00AC2:  MOVLW  0C
00AC4:  MOVLB  5
00AC6:  ADDWF  01,W
00AC8:  MOVWF  01
00ACA:  MOVLW  00
00ACC:  ADDWFC 02,W
00ACE:  MOVWF  03
00AD0:  MOVF   01,W
00AD2:  ADDLW  20
00AD4:  MOVWF  FE9
00AD6:  MOVLW  00
00AD8:  ADDWFC 03,W
00ADA:  MOVWF  FEA
00ADC:  MOVFF  FEC,03
00AE0:  MOVF   FED,F
00AE2:  MOVFF  FEF,577
00AE6:  MOVFF  576,FEA
00AEA:  MOVFF  575,FE9
00AEE:  MOVFF  03,FEC
00AF2:  MOVF   FED,F
00AF4:  MOVFF  577,FEF
.................... 	  } 
....................  
.................... 	if ( servo[s].pwDestination > servo[s].max ) { 
00AF8:  CLRF   x79
00AFA:  MOVFF  574,578
00AFE:  CLRF   x7B
00B00:  MOVLW  18
00B02:  MOVWF  x7A
00B04:  MOVLB  0
00B06:  RCALL  0492
00B08:  MOVFF  01,575
00B0C:  MOVLW  03
00B0E:  MOVLB  5
00B10:  ADDWF  01,W
00B12:  MOVWF  01
00B14:  MOVLW  00
00B16:  ADDWFC 02,W
00B18:  MOVWF  03
00B1A:  MOVF   01,W
00B1C:  ADDLW  20
00B1E:  MOVWF  FE9
00B20:  MOVLW  00
00B22:  ADDWFC 03,W
00B24:  MOVWF  FEA
00B26:  MOVFF  FEC,576
00B2A:  MOVF   FED,F
00B2C:  MOVFF  FEF,575
00B30:  CLRF   x79
00B32:  MOVFF  574,578
00B36:  CLRF   x7B
00B38:  MOVLW  18
00B3A:  MOVWF  x7A
00B3C:  MOVLB  0
00B3E:  RCALL  0492
00B40:  MOVFF  02,578
00B44:  MOVFF  01,577
00B48:  MOVLW  0E
00B4A:  MOVLB  5
00B4C:  ADDWF  01,W
00B4E:  MOVWF  01
00B50:  MOVLW  00
00B52:  ADDWFC 02,W
00B54:  MOVWF  03
00B56:  MOVF   01,W
00B58:  ADDLW  20
00B5A:  MOVWF  FE9
00B5C:  MOVLW  00
00B5E:  ADDWFC 03,W
00B60:  MOVWF  FEA
00B62:  MOVFF  FEC,03
00B66:  MOVF   FED,F
00B68:  MOVFF  FEF,01
00B6C:  MOVF   03,W
00B6E:  SUBWF  x76,W
00B70:  BNC   0BF8
00B72:  BNZ   0B7A
00B74:  MOVF   x75,W
00B76:  SUBWF  01,W
00B78:  BC    0BF8
.................... 	  servo[s].pwDestination = servo[s].max; 
00B7A:  CLRF   x79
00B7C:  MOVFF  574,578
00B80:  CLRF   x7B
00B82:  MOVLW  18
00B84:  MOVWF  x7A
00B86:  MOVLB  0
00B88:  RCALL  0492
00B8A:  MOVFF  01,575
00B8E:  MOVLW  03
00B90:  MOVLB  5
00B92:  ADDWF  01,W
00B94:  MOVWF  01
00B96:  MOVLW  00
00B98:  ADDWFC 02,W
00B9A:  MOVWF  03
00B9C:  MOVF   01,W
00B9E:  ADDLW  20
00BA0:  MOVWF  01
00BA2:  MOVLW  00
00BA4:  ADDWFC 03,F
00BA6:  MOVFF  01,575
00BAA:  MOVFF  03,576
00BAE:  CLRF   x79
00BB0:  MOVFF  574,578
00BB4:  CLRF   x7B
00BB6:  MOVLW  18
00BB8:  MOVWF  x7A
00BBA:  MOVLB  0
00BBC:  RCALL  0492
00BBE:  MOVFF  01,577
00BC2:  MOVLW  0E
00BC4:  MOVLB  5
00BC6:  ADDWF  01,W
00BC8:  MOVWF  01
00BCA:  MOVLW  00
00BCC:  ADDWFC 02,W
00BCE:  MOVWF  03
00BD0:  MOVF   01,W
00BD2:  ADDLW  20
00BD4:  MOVWF  FE9
00BD6:  MOVLW  00
00BD8:  ADDWFC 03,W
00BDA:  MOVWF  FEA
00BDC:  MOVFF  FEC,03
00BE0:  MOVF   FED,F
00BE2:  MOVFF  FEF,577
00BE6:  MOVFF  576,FEA
00BEA:  MOVFF  575,FE9
00BEE:  MOVFF  03,FEC
00BF2:  MOVF   FED,F
00BF4:  MOVFF  577,FEF
.................... 	  } 
.................... } 
00BF8:  MOVLB  0
00BFA:  RETLW  00
....................  
....................  
.................... void servoUpdateStep(int8 i) 
.................... { 
.................... 	if ( servo[i].step == 0 ) 
00BFC:  MOVLB  5
00BFE:  CLRF   x79
00C00:  MOVFF  55E,578
00C04:  CLRF   x7B
00C06:  MOVLW  18
00C08:  MOVWF  x7A
00C0A:  MOVLB  0
00C0C:  RCALL  0492
00C0E:  MOVFF  01,55F
00C12:  MOVLW  05
00C14:  MOVLB  5
00C16:  ADDWF  01,W
00C18:  MOVWF  01
00C1A:  MOVLW  00
00C1C:  ADDWFC 02,W
00C1E:  MOVWF  03
00C20:  MOVF   01,W
00C22:  ADDLW  20
00C24:  MOVWF  FE9
00C26:  MOVLW  00
00C28:  ADDWFC 03,W
00C2A:  MOVWF  FEA
00C2C:  MOVFF  FEC,560
00C30:  MOVF   FED,F
00C32:  MOVFF  FEF,55F
00C36:  MOVF   x5F,F
00C38:  BNZ   0CBE
00C3A:  MOVF   x60,F
00C3C:  BNZ   0CBE
.................... 	  { 
.................... 	  servo[i].pwCurrent = servo[i].pwDestination; 
00C3E:  CLRF   x79
00C40:  MOVFF  55E,578
00C44:  CLRF   x7B
00C46:  MOVLW  18
00C48:  MOVWF  x7A
00C4A:  MOVLB  0
00C4C:  RCALL  0492
00C4E:  MOVFF  01,55F
00C52:  MOVLW  01
00C54:  MOVLB  5
00C56:  ADDWF  01,W
00C58:  MOVWF  01
00C5A:  MOVLW  00
00C5C:  ADDWFC 02,W
00C5E:  MOVWF  03
00C60:  MOVF   01,W
00C62:  ADDLW  20
00C64:  MOVWF  01
00C66:  MOVLW  00
00C68:  ADDWFC 03,F
00C6A:  MOVFF  01,55F
00C6E:  MOVFF  03,560
00C72:  CLRF   x79
00C74:  MOVFF  55E,578
00C78:  CLRF   x7B
00C7A:  MOVLW  18
00C7C:  MOVWF  x7A
00C7E:  MOVLB  0
00C80:  RCALL  0492
00C82:  MOVFF  01,561
00C86:  MOVLW  03
00C88:  MOVLB  5
00C8A:  ADDWF  01,W
00C8C:  MOVWF  01
00C8E:  MOVLW  00
00C90:  ADDWFC 02,W
00C92:  MOVWF  03
00C94:  MOVF   01,W
00C96:  ADDLW  20
00C98:  MOVWF  FE9
00C9A:  MOVLW  00
00C9C:  ADDWFC 03,W
00C9E:  MOVWF  FEA
00CA0:  MOVFF  FEC,03
00CA4:  MOVF   FED,F
00CA6:  MOVFF  FEF,561
00CAA:  MOVFF  560,FEA
00CAE:  MOVFF  55F,FE9
00CB2:  MOVFF  03,FEC
00CB6:  MOVF   FED,F
00CB8:  MOVFF  561,FEF
.................... 	  //servo[i].pwCurrent = 1550; // testing 
.................... 	  } 
.................... 	else 
00CBC:  BRA    1164
.................... 	  { 
.................... 	  if ( servo[i].pwCurrent < servo[i].pwDestination ) 
00CBE:  CLRF   x79
00CC0:  MOVFF  55E,578
00CC4:  CLRF   x7B
00CC6:  MOVLW  18
00CC8:  MOVWF  x7A
00CCA:  MOVLB  0
00CCC:  CALL   0492
00CD0:  MOVFF  01,55F
00CD4:  MOVLW  01
00CD6:  MOVLB  5
00CD8:  ADDWF  01,W
00CDA:  MOVWF  01
00CDC:  MOVLW  00
00CDE:  ADDWFC 02,W
00CE0:  MOVWF  03
00CE2:  MOVF   01,W
00CE4:  ADDLW  20
00CE6:  MOVWF  FE9
00CE8:  MOVLW  00
00CEA:  ADDWFC 03,W
00CEC:  MOVWF  FEA
00CEE:  MOVFF  FEC,560
00CF2:  MOVF   FED,F
00CF4:  MOVFF  FEF,55F
00CF8:  CLRF   x79
00CFA:  MOVFF  55E,578
00CFE:  CLRF   x7B
00D00:  MOVLW  18
00D02:  MOVWF  x7A
00D04:  MOVLB  0
00D06:  CALL   0492
00D0A:  MOVFF  02,562
00D0E:  MOVFF  01,561
00D12:  MOVLW  03
00D14:  MOVLB  5
00D16:  ADDWF  01,W
00D18:  MOVWF  01
00D1A:  MOVLW  00
00D1C:  ADDWFC 02,W
00D1E:  MOVWF  03
00D20:  MOVF   01,W
00D22:  ADDLW  20
00D24:  MOVWF  FE9
00D26:  MOVLW  00
00D28:  ADDWFC 03,W
00D2A:  MOVWF  FEA
00D2C:  MOVFF  FEC,03
00D30:  MOVF   FED,F
00D32:  MOVFF  FEF,01
00D36:  MOVF   x60,W
00D38:  SUBWF  03,W
00D3A:  BTFSS  FD8.0
00D3C:  BRA    0F12
00D3E:  BNZ   0D48
00D40:  MOVF   01,W
00D42:  SUBWF  x5F,W
00D44:  BTFSC  FD8.0
00D46:  BRA    0F12
.................... 	    { 
.................... 	    servo[i].pwCurrent = servo[i].pwCurrent + servo[i].step; 
00D48:  CLRF   x79
00D4A:  MOVFF  55E,578
00D4E:  CLRF   x7B
00D50:  MOVLW  18
00D52:  MOVWF  x7A
00D54:  MOVLB  0
00D56:  CALL   0492
00D5A:  MOVFF  01,55F
00D5E:  MOVLW  01
00D60:  MOVLB  5
00D62:  ADDWF  01,W
00D64:  MOVWF  01
00D66:  MOVLW  00
00D68:  ADDWFC 02,W
00D6A:  MOVWF  03
00D6C:  MOVF   01,W
00D6E:  ADDLW  20
00D70:  MOVWF  01
00D72:  MOVLW  00
00D74:  ADDWFC 03,F
00D76:  MOVFF  01,55F
00D7A:  MOVFF  03,560
00D7E:  CLRF   x79
00D80:  MOVFF  55E,578
00D84:  CLRF   x7B
00D86:  MOVLW  18
00D88:  MOVWF  x7A
00D8A:  MOVLB  0
00D8C:  CALL   0492
00D90:  MOVFF  01,561
00D94:  MOVLW  01
00D96:  MOVLB  5
00D98:  ADDWF  01,W
00D9A:  MOVWF  01
00D9C:  MOVLW  00
00D9E:  ADDWFC 02,W
00DA0:  MOVWF  03
00DA2:  MOVF   01,W
00DA4:  ADDLW  20
00DA6:  MOVWF  FE9
00DA8:  MOVLW  00
00DAA:  ADDWFC 03,W
00DAC:  MOVWF  FEA
00DAE:  MOVFF  FEC,562
00DB2:  MOVF   FED,F
00DB4:  MOVFF  FEF,561
00DB8:  CLRF   x79
00DBA:  MOVFF  55E,578
00DBE:  CLRF   x7B
00DC0:  MOVLW  18
00DC2:  MOVWF  x7A
00DC4:  MOVLB  0
00DC6:  CALL   0492
00DCA:  MOVFF  01,563
00DCE:  MOVLW  05
00DD0:  MOVLB  5
00DD2:  ADDWF  01,W
00DD4:  MOVWF  01
00DD6:  MOVLW  00
00DD8:  ADDWFC 02,W
00DDA:  MOVWF  03
00DDC:  MOVF   01,W
00DDE:  ADDLW  20
00DE0:  MOVWF  FE9
00DE2:  MOVLW  00
00DE4:  ADDWFC 03,W
00DE6:  MOVWF  FEA
00DE8:  MOVFF  FEC,03
00DEC:  MOVF   FED,F
00DEE:  MOVF   FEF,W
00DF0:  ADDWF  x61,W
00DF2:  MOVWF  01
00DF4:  MOVF   x62,W
00DF6:  ADDWFC 03,F
00DF8:  MOVFF  560,FEA
00DFC:  MOVFF  55F,FE9
00E00:  MOVFF  03,FEC
00E04:  MOVF   FED,F
00E06:  MOVFF  01,FEF
.................... 	    // this is in case of overshoot 
.................... 	    if ( servo[i].pwCurrent > servo[i].pwDestination ) 
00E0A:  CLRF   x79
00E0C:  MOVFF  55E,578
00E10:  CLRF   x7B
00E12:  MOVLW  18
00E14:  MOVWF  x7A
00E16:  MOVLB  0
00E18:  CALL   0492
00E1C:  MOVFF  01,55F
00E20:  MOVLW  01
00E22:  MOVLB  5
00E24:  ADDWF  01,W
00E26:  MOVWF  01
00E28:  MOVLW  00
00E2A:  ADDWFC 02,W
00E2C:  MOVWF  03
00E2E:  MOVF   01,W
00E30:  ADDLW  20
00E32:  MOVWF  FE9
00E34:  MOVLW  00
00E36:  ADDWFC 03,W
00E38:  MOVWF  FEA
00E3A:  MOVFF  FEC,560
00E3E:  MOVF   FED,F
00E40:  MOVFF  FEF,55F
00E44:  CLRF   x79
00E46:  MOVFF  55E,578
00E4A:  CLRF   x7B
00E4C:  MOVLW  18
00E4E:  MOVWF  x7A
00E50:  MOVLB  0
00E52:  CALL   0492
00E56:  MOVFF  02,562
00E5A:  MOVFF  01,561
00E5E:  MOVLW  03
00E60:  MOVLB  5
00E62:  ADDWF  01,W
00E64:  MOVWF  01
00E66:  MOVLW  00
00E68:  ADDWFC 02,W
00E6A:  MOVWF  03
00E6C:  MOVF   01,W
00E6E:  ADDLW  20
00E70:  MOVWF  FE9
00E72:  MOVLW  00
00E74:  ADDWFC 03,W
00E76:  MOVWF  FEA
00E78:  MOVFF  FEC,03
00E7C:  MOVF   FED,F
00E7E:  MOVFF  FEF,01
00E82:  MOVF   03,W
00E84:  SUBWF  x60,W
00E86:  BNC   0F12
00E88:  BNZ   0E90
00E8A:  MOVF   x5F,W
00E8C:  SUBWF  01,W
00E8E:  BC    0F12
.................... 	      { 
....................  		  servo[i].pwCurrent = servo[i].pwDestination; 
00E90:  CLRF   x79
00E92:  MOVFF  55E,578
00E96:  CLRF   x7B
00E98:  MOVLW  18
00E9A:  MOVWF  x7A
00E9C:  MOVLB  0
00E9E:  CALL   0492
00EA2:  MOVFF  01,55F
00EA6:  MOVLW  01
00EA8:  MOVLB  5
00EAA:  ADDWF  01,W
00EAC:  MOVWF  01
00EAE:  MOVLW  00
00EB0:  ADDWFC 02,W
00EB2:  MOVWF  03
00EB4:  MOVF   01,W
00EB6:  ADDLW  20
00EB8:  MOVWF  01
00EBA:  MOVLW  00
00EBC:  ADDWFC 03,F
00EBE:  MOVFF  01,55F
00EC2:  MOVFF  03,560
00EC6:  CLRF   x79
00EC8:  MOVFF  55E,578
00ECC:  CLRF   x7B
00ECE:  MOVLW  18
00ED0:  MOVWF  x7A
00ED2:  MOVLB  0
00ED4:  CALL   0492
00ED8:  MOVFF  01,561
00EDC:  MOVLW  03
00EDE:  MOVLB  5
00EE0:  ADDWF  01,W
00EE2:  MOVWF  01
00EE4:  MOVLW  00
00EE6:  ADDWFC 02,W
00EE8:  MOVWF  03
00EEA:  MOVF   01,W
00EEC:  ADDLW  20
00EEE:  MOVWF  FE9
00EF0:  MOVLW  00
00EF2:  ADDWFC 03,W
00EF4:  MOVWF  FEA
00EF6:  MOVFF  FEC,03
00EFA:  MOVF   FED,F
00EFC:  MOVFF  FEF,561
00F00:  MOVFF  560,FEA
00F04:  MOVFF  55F,FE9
00F08:  MOVFF  03,FEC
00F0C:  MOVF   FED,F
00F0E:  MOVFF  561,FEF
.................... 		  } 
.................... 	    } 
....................  
.................... 	  if ( servo[i].pwCurrent > servo[i].pwDestination ) 
00F12:  CLRF   x79
00F14:  MOVFF  55E,578
00F18:  CLRF   x7B
00F1A:  MOVLW  18
00F1C:  MOVWF  x7A
00F1E:  MOVLB  0
00F20:  CALL   0492
00F24:  MOVFF  01,55F
00F28:  MOVLW  01
00F2A:  MOVLB  5
00F2C:  ADDWF  01,W
00F2E:  MOVWF  01
00F30:  MOVLW  00
00F32:  ADDWFC 02,W
00F34:  MOVWF  03
00F36:  MOVF   01,W
00F38:  ADDLW  20
00F3A:  MOVWF  FE9
00F3C:  MOVLW  00
00F3E:  ADDWFC 03,W
00F40:  MOVWF  FEA
00F42:  MOVFF  FEC,560
00F46:  MOVF   FED,F
00F48:  MOVFF  FEF,55F
00F4C:  CLRF   x79
00F4E:  MOVFF  55E,578
00F52:  CLRF   x7B
00F54:  MOVLW  18
00F56:  MOVWF  x7A
00F58:  MOVLB  0
00F5A:  CALL   0492
00F5E:  MOVFF  02,562
00F62:  MOVFF  01,561
00F66:  MOVLW  03
00F68:  MOVLB  5
00F6A:  ADDWF  01,W
00F6C:  MOVWF  01
00F6E:  MOVLW  00
00F70:  ADDWFC 02,W
00F72:  MOVWF  03
00F74:  MOVF   01,W
00F76:  ADDLW  20
00F78:  MOVWF  FE9
00F7A:  MOVLW  00
00F7C:  ADDWFC 03,W
00F7E:  MOVWF  FEA
00F80:  MOVFF  FEC,03
00F84:  MOVF   FED,F
00F86:  MOVFF  FEF,01
00F8A:  MOVF   03,W
00F8C:  SUBWF  x60,W
00F8E:  BTFSS  FD8.0
00F90:  BRA    1164
00F92:  BNZ   0F9C
00F94:  MOVF   x5F,W
00F96:  SUBWF  01,W
00F98:  BTFSC  FD8.0
00F9A:  BRA    1164
.................... 	    { 
.................... 	    servo[i].pwCurrent = servo[i].pwCurrent - servo[i].step; 
00F9C:  CLRF   x79
00F9E:  MOVFF  55E,578
00FA2:  CLRF   x7B
00FA4:  MOVLW  18
00FA6:  MOVWF  x7A
00FA8:  MOVLB  0
00FAA:  CALL   0492
00FAE:  MOVFF  01,55F
00FB2:  MOVLW  01
00FB4:  MOVLB  5
00FB6:  ADDWF  01,W
00FB8:  MOVWF  01
00FBA:  MOVLW  00
00FBC:  ADDWFC 02,W
00FBE:  MOVWF  03
00FC0:  MOVF   01,W
00FC2:  ADDLW  20
00FC4:  MOVWF  01
00FC6:  MOVLW  00
00FC8:  ADDWFC 03,F
00FCA:  MOVFF  01,55F
00FCE:  MOVFF  03,560
00FD2:  CLRF   x79
00FD4:  MOVFF  55E,578
00FD8:  CLRF   x7B
00FDA:  MOVLW  18
00FDC:  MOVWF  x7A
00FDE:  MOVLB  0
00FE0:  CALL   0492
00FE4:  MOVFF  01,561
00FE8:  MOVLW  01
00FEA:  MOVLB  5
00FEC:  ADDWF  01,W
00FEE:  MOVWF  01
00FF0:  MOVLW  00
00FF2:  ADDWFC 02,W
00FF4:  MOVWF  03
00FF6:  MOVF   01,W
00FF8:  ADDLW  20
00FFA:  MOVWF  FE9
00FFC:  MOVLW  00
00FFE:  ADDWFC 03,W
01000:  MOVWF  FEA
01002:  MOVFF  FEC,562
01006:  MOVF   FED,F
01008:  MOVFF  FEF,561
0100C:  CLRF   x79
0100E:  MOVFF  55E,578
01012:  CLRF   x7B
01014:  MOVLW  18
01016:  MOVWF  x7A
01018:  MOVLB  0
0101A:  CALL   0492
0101E:  MOVFF  01,563
01022:  MOVLW  05
01024:  MOVLB  5
01026:  ADDWF  01,W
01028:  MOVWF  01
0102A:  MOVLW  00
0102C:  ADDWFC 02,W
0102E:  MOVWF  03
01030:  MOVF   01,W
01032:  ADDLW  20
01034:  MOVWF  FE9
01036:  MOVLW  00
01038:  ADDWFC 03,W
0103A:  MOVWF  FEA
0103C:  MOVFF  FEC,03
01040:  MOVF   FED,F
01042:  MOVF   FEF,W
01044:  SUBWF  x61,W
01046:  MOVWF  00
01048:  MOVF   03,W
0104A:  SUBWFB x62,W
0104C:  MOVFF  560,FEA
01050:  MOVFF  55F,FE9
01054:  MOVWF  FEC
01056:  MOVF   FED,F
01058:  MOVFF  00,FEF
.................... 	    // this is in case of overshoot 
.................... 	    if ( servo[i].pwCurrent < servo[i].pwDestination )  
0105C:  CLRF   x79
0105E:  MOVFF  55E,578
01062:  CLRF   x7B
01064:  MOVLW  18
01066:  MOVWF  x7A
01068:  MOVLB  0
0106A:  CALL   0492
0106E:  MOVFF  01,55F
01072:  MOVLW  01
01074:  MOVLB  5
01076:  ADDWF  01,W
01078:  MOVWF  01
0107A:  MOVLW  00
0107C:  ADDWFC 02,W
0107E:  MOVWF  03
01080:  MOVF   01,W
01082:  ADDLW  20
01084:  MOVWF  FE9
01086:  MOVLW  00
01088:  ADDWFC 03,W
0108A:  MOVWF  FEA
0108C:  MOVFF  FEC,560
01090:  MOVF   FED,F
01092:  MOVFF  FEF,55F
01096:  CLRF   x79
01098:  MOVFF  55E,578
0109C:  CLRF   x7B
0109E:  MOVLW  18
010A0:  MOVWF  x7A
010A2:  MOVLB  0
010A4:  CALL   0492
010A8:  MOVFF  02,562
010AC:  MOVFF  01,561
010B0:  MOVLW  03
010B2:  MOVLB  5
010B4:  ADDWF  01,W
010B6:  MOVWF  01
010B8:  MOVLW  00
010BA:  ADDWFC 02,W
010BC:  MOVWF  03
010BE:  MOVF   01,W
010C0:  ADDLW  20
010C2:  MOVWF  FE9
010C4:  MOVLW  00
010C6:  ADDWFC 03,W
010C8:  MOVWF  FEA
010CA:  MOVFF  FEC,03
010CE:  MOVF   FED,F
010D0:  MOVFF  FEF,01
010D4:  MOVF   x60,W
010D6:  SUBWF  03,W
010D8:  BNC   1164
010DA:  BNZ   10E2
010DC:  MOVF   01,W
010DE:  SUBWF  x5F,W
010E0:  BC    1164
.................... 	      { 
.................... 		  servo[i].pwCurrent = servo[i].pwDestination; 
010E2:  CLRF   x79
010E4:  MOVFF  55E,578
010E8:  CLRF   x7B
010EA:  MOVLW  18
010EC:  MOVWF  x7A
010EE:  MOVLB  0
010F0:  CALL   0492
010F4:  MOVFF  01,55F
010F8:  MOVLW  01
010FA:  MOVLB  5
010FC:  ADDWF  01,W
010FE:  MOVWF  01
01100:  MOVLW  00
01102:  ADDWFC 02,W
01104:  MOVWF  03
01106:  MOVF   01,W
01108:  ADDLW  20
0110A:  MOVWF  01
0110C:  MOVLW  00
0110E:  ADDWFC 03,F
01110:  MOVFF  01,55F
01114:  MOVFF  03,560
01118:  CLRF   x79
0111A:  MOVFF  55E,578
0111E:  CLRF   x7B
01120:  MOVLW  18
01122:  MOVWF  x7A
01124:  MOVLB  0
01126:  CALL   0492
0112A:  MOVFF  01,561
0112E:  MOVLW  03
01130:  MOVLB  5
01132:  ADDWF  01,W
01134:  MOVWF  01
01136:  MOVLW  00
01138:  ADDWFC 02,W
0113A:  MOVWF  03
0113C:  MOVF   01,W
0113E:  ADDLW  20
01140:  MOVWF  FE9
01142:  MOVLW  00
01144:  ADDWFC 03,W
01146:  MOVWF  FEA
01148:  MOVFF  FEC,03
0114C:  MOVF   FED,F
0114E:  MOVFF  FEF,561
01152:  MOVFF  560,FEA
01156:  MOVFF  55F,FE9
0115A:  MOVFF  03,FEC
0115E:  MOVF   FED,F
01160:  MOVFF  561,FEF
.................... 		  } 
.................... 	    } 
.................... 	  } 
....................  
.................... } 
01164:  MOVLB  0
01166:  RETLW  00
....................  
....................  
.................... void servoCalcTimeOuts(void) 
.................... { 
.................... 	int8 i; 
.................... 	#ifdef DEBUG_MSG 
.................... 	  puts("servoCalcTimeOuts()",debug); 
.................... 	#endif 
.................... 	mServoLoop 
01168:  MOVLB  5
0116A:  CLRF   x5D
0116C:  MOVF   x5D,W
0116E:  SUBLW  1F
01170:  BTFSS  FD8.0
01172:  BRA    16D8
.................... 	  { 
.................... 	  boundsCheck(i); 
01174:  MOVFF  55D,574
01178:  MOVLB  0
0117A:  RCALL  09F6
.................... 	  if ( servo[i].mode == MODE_NORMAL ) 
0117C:  MOVLB  5
0117E:  CLRF   x79
01180:  MOVFF  55D,578
01184:  CLRF   x7B
01186:  MOVLW  18
01188:  MOVWF  x7A
0118A:  MOVLB  0
0118C:  CALL   0492
01190:  MOVFF  02,55F
01194:  MOVFF  01,55E
01198:  MOVLW  20
0119A:  MOVLB  5
0119C:  ADDWF  01,W
0119E:  MOVWF  FE9
011A0:  MOVLW  00
011A2:  ADDWFC 02,W
011A4:  MOVWF  FEA
011A6:  DECFSZ FEF,W
011A8:  BRA    1236
.................... 	    { 
.................... 	    servoUpdateStep(i); 
011AA:  MOVFF  55D,55E
011AE:  MOVLB  0
011B0:  RCALL  0BFC
.................... 	    servo[i].timeOut = servo[i].pwCurrent; 
011B2:  MOVLB  5
011B4:  CLRF   x79
011B6:  MOVFF  55D,578
011BA:  CLRF   x7B
011BC:  MOVLW  18
011BE:  MOVWF  x7A
011C0:  MOVLB  0
011C2:  CALL   0492
011C6:  MOVFF  01,55E
011CA:  MOVLW  16
011CC:  MOVLB  5
011CE:  ADDWF  01,W
011D0:  MOVWF  01
011D2:  MOVLW  00
011D4:  ADDWFC 02,W
011D6:  MOVWF  03
011D8:  MOVF   01,W
011DA:  ADDLW  20
011DC:  MOVWF  01
011DE:  MOVLW  00
011E0:  ADDWFC 03,F
011E2:  MOVFF  01,55E
011E6:  MOVFF  03,55F
011EA:  CLRF   x79
011EC:  MOVFF  55D,578
011F0:  CLRF   x7B
011F2:  MOVLW  18
011F4:  MOVWF  x7A
011F6:  MOVLB  0
011F8:  CALL   0492
011FC:  MOVFF  01,560
01200:  MOVLW  01
01202:  MOVLB  5
01204:  ADDWF  01,W
01206:  MOVWF  01
01208:  MOVLW  00
0120A:  ADDWFC 02,W
0120C:  MOVWF  03
0120E:  MOVF   01,W
01210:  ADDLW  20
01212:  MOVWF  FE9
01214:  MOVLW  00
01216:  ADDWFC 03,W
01218:  MOVWF  FEA
0121A:  MOVFF  FEC,03
0121E:  MOVF   FED,F
01220:  MOVFF  FEF,560
01224:  MOVFF  55F,FEA
01228:  MOVFF  55E,FE9
0122C:  MOVFF  03,FEC
01230:  MOVF   FED,F
01232:  MOVFF  560,FEF
.................... 		} 
.................... 		 
.................... 	  if ( servo[i].mode == MODE_COPY ) 
01236:  CLRF   x79
01238:  MOVFF  55D,578
0123C:  CLRF   x7B
0123E:  MOVLW  18
01240:  MOVWF  x7A
01242:  MOVLB  0
01244:  CALL   0492
01248:  MOVFF  02,55F
0124C:  MOVFF  01,55E
01250:  MOVLW  20
01252:  MOVLB  5
01254:  ADDWF  01,W
01256:  MOVWF  FE9
01258:  MOVLW  00
0125A:  ADDWFC 02,W
0125C:  MOVWF  FEA
0125E:  MOVF   FEF,W
01260:  SUBLW  02
01262:  BNZ   131A
.................... 	    { 
.................... 	    servo[i].timeOut = servo[servo[i].master].pwCurrent; 
01264:  CLRF   x79
01266:  MOVFF  55D,578
0126A:  CLRF   x7B
0126C:  MOVLW  18
0126E:  MOVWF  x7A
01270:  MOVLB  0
01272:  CALL   0492
01276:  MOVFF  01,55E
0127A:  MOVLW  16
0127C:  MOVLB  5
0127E:  ADDWF  01,W
01280:  MOVWF  01
01282:  MOVLW  00
01284:  ADDWFC 02,W
01286:  MOVWF  03
01288:  MOVF   01,W
0128A:  ADDLW  20
0128C:  MOVWF  01
0128E:  MOVLW  00
01290:  ADDWFC 03,F
01292:  MOVFF  01,55E
01296:  MOVFF  03,55F
0129A:  CLRF   x79
0129C:  MOVFF  55D,578
012A0:  CLRF   x7B
012A2:  MOVLW  18
012A4:  MOVWF  x7A
012A6:  MOVLB  0
012A8:  CALL   0492
012AC:  MOVFF  02,561
012B0:  MOVFF  01,560
012B4:  MOVLW  14
012B6:  MOVLB  5
012B8:  ADDWF  01,W
012BA:  MOVWF  01
012BC:  MOVLW  00
012BE:  ADDWFC 02,W
012C0:  MOVWF  03
012C2:  MOVF   01,W
012C4:  ADDLW  20
012C6:  MOVWF  FE9
012C8:  MOVLW  00
012CA:  ADDWFC 03,W
012CC:  MOVWF  FEA
012CE:  CLRF   x79
012D0:  MOVFF  FEF,578
012D4:  CLRF   x7B
012D6:  MOVLW  18
012D8:  MOVWF  x7A
012DA:  MOVLB  0
012DC:  CALL   0492
012E0:  MOVFF  01,560
012E4:  MOVLW  01
012E6:  MOVLB  5
012E8:  ADDWF  01,W
012EA:  MOVWF  01
012EC:  MOVLW  00
012EE:  ADDWFC 02,W
012F0:  MOVWF  03
012F2:  MOVF   01,W
012F4:  ADDLW  20
012F6:  MOVWF  FE9
012F8:  MOVLW  00
012FA:  ADDWFC 03,W
012FC:  MOVWF  FEA
012FE:  MOVFF  FEC,03
01302:  MOVF   FED,F
01304:  MOVFF  FEF,560
01308:  MOVFF  55F,FEA
0130C:  MOVFF  55E,FE9
01310:  MOVFF  03,FEC
01314:  MOVF   FED,F
01316:  MOVFF  560,FEF
.................... 		} 
.................... 		 
.................... 	  if ( servo[i].mode == MODE_MIRROR ) 
0131A:  CLRF   x79
0131C:  MOVFF  55D,578
01320:  CLRF   x7B
01322:  MOVLW  18
01324:  MOVWF  x7A
01326:  MOVLB  0
01328:  CALL   0492
0132C:  MOVFF  02,55F
01330:  MOVFF  01,55E
01334:  MOVLW  20
01336:  MOVLB  5
01338:  ADDWF  01,W
0133A:  MOVWF  FE9
0133C:  MOVLW  00
0133E:  ADDWFC 02,W
01340:  MOVWF  FEA
01342:  MOVF   FEF,W
01344:  SUBLW  03
01346:  BTFSS  FD8.2
01348:  BRA    1560
.................... 	    { 
.................... 	    if (servo[servo[i].master].pwCurrent > PW_CENTER) 
0134A:  CLRF   x79
0134C:  MOVFF  55D,578
01350:  CLRF   x7B
01352:  MOVLW  18
01354:  MOVWF  x7A
01356:  MOVLB  0
01358:  CALL   0492
0135C:  MOVFF  02,55F
01360:  MOVFF  01,55E
01364:  MOVLW  14
01366:  MOVLB  5
01368:  ADDWF  01,W
0136A:  MOVWF  01
0136C:  MOVLW  00
0136E:  ADDWFC 02,W
01370:  MOVWF  03
01372:  MOVF   01,W
01374:  ADDLW  20
01376:  MOVWF  FE9
01378:  MOVLW  00
0137A:  ADDWFC 03,W
0137C:  MOVWF  FEA
0137E:  CLRF   x79
01380:  MOVFF  FEF,578
01384:  CLRF   x7B
01386:  MOVLW  18
01388:  MOVWF  x7A
0138A:  MOVLB  0
0138C:  CALL   0492
01390:  MOVFF  01,55E
01394:  MOVLW  01
01396:  MOVLB  5
01398:  ADDWF  01,W
0139A:  MOVWF  01
0139C:  MOVLW  00
0139E:  ADDWFC 02,W
013A0:  MOVWF  03
013A2:  MOVF   01,W
013A4:  ADDLW  20
013A6:  MOVWF  FE9
013A8:  MOVLW  00
013AA:  ADDWFC 03,W
013AC:  MOVWF  FEA
013AE:  MOVFF  FEC,55F
013B2:  MOVF   FED,F
013B4:  MOVFF  FEF,55E
013B8:  MOVF   x5F,W
013BA:  SUBLW  04
013BC:  BC    1498
013BE:  XORLW  FF
013C0:  BNZ   13C8
013C2:  MOVF   x5E,W
013C4:  SUBLW  DC
013C6:  BC    1498
.................... 		  { 
.................... 		  servo[i].timeOut = PW_CENTER - (servo[servo[i].master].pwCurrent - PW_CENTER); 
013C8:  CLRF   x79
013CA:  MOVFF  55D,578
013CE:  CLRF   x7B
013D0:  MOVLW  18
013D2:  MOVWF  x7A
013D4:  MOVLB  0
013D6:  CALL   0492
013DA:  MOVFF  01,55E
013DE:  MOVLW  16
013E0:  MOVLB  5
013E2:  ADDWF  01,W
013E4:  MOVWF  01
013E6:  MOVLW  00
013E8:  ADDWFC 02,W
013EA:  MOVWF  03
013EC:  MOVF   01,W
013EE:  ADDLW  20
013F0:  MOVWF  01
013F2:  MOVLW  00
013F4:  ADDWFC 03,F
013F6:  MOVFF  01,55E
013FA:  MOVFF  03,55F
013FE:  CLRF   x79
01400:  MOVFF  55D,578
01404:  CLRF   x7B
01406:  MOVLW  18
01408:  MOVWF  x7A
0140A:  MOVLB  0
0140C:  CALL   0492
01410:  MOVFF  02,561
01414:  MOVFF  01,560
01418:  MOVLW  14
0141A:  MOVLB  5
0141C:  ADDWF  01,W
0141E:  MOVWF  01
01420:  MOVLW  00
01422:  ADDWFC 02,W
01424:  MOVWF  03
01426:  MOVF   01,W
01428:  ADDLW  20
0142A:  MOVWF  FE9
0142C:  MOVLW  00
0142E:  ADDWFC 03,W
01430:  MOVWF  FEA
01432:  CLRF   x79
01434:  MOVFF  FEF,578
01438:  CLRF   x7B
0143A:  MOVLW  18
0143C:  MOVWF  x7A
0143E:  MOVLB  0
01440:  CALL   0492
01444:  MOVFF  01,560
01448:  MOVLW  01
0144A:  MOVLB  5
0144C:  ADDWF  01,W
0144E:  MOVWF  01
01450:  MOVLW  00
01452:  ADDWFC 02,W
01454:  MOVWF  03
01456:  MOVF   01,W
01458:  ADDLW  20
0145A:  MOVWF  FE9
0145C:  MOVLW  00
0145E:  ADDWFC 03,W
01460:  MOVWF  FEA
01462:  MOVFF  FEC,561
01466:  MOVF   FED,F
01468:  MOVFF  FEF,560
0146C:  MOVLW  DC
0146E:  SUBWF  x60,W
01470:  MOVWF  00
01472:  MOVLW  05
01474:  SUBWFB x61,W
01476:  MOVWF  03
01478:  MOVF   00,W
0147A:  XORLW  FF
0147C:  ADDLW  DD
0147E:  MOVWF  00
01480:  MOVLW  05
01482:  SUBFWB 03,F
01484:  MOVFF  55F,FEA
01488:  MOVFF  55E,FE9
0148C:  MOVFF  03,FEC
01490:  MOVF   FED,F
01492:  MOVFF  00,FEF
.................... 		  } 
.................... 		else 
01496:  BRA    1560
.................... 		  { 
.................... 		  servo[i].timeOut = (PW_CENTER - servo[servo[i].master].pwCurrent) + PW_CENTER; 
01498:  CLRF   x79
0149A:  MOVFF  55D,578
0149E:  CLRF   x7B
014A0:  MOVLW  18
014A2:  MOVWF  x7A
014A4:  MOVLB  0
014A6:  CALL   0492
014AA:  MOVFF  01,55E
014AE:  MOVLW  16
014B0:  MOVLB  5
014B2:  ADDWF  01,W
014B4:  MOVWF  01
014B6:  MOVLW  00
014B8:  ADDWFC 02,W
014BA:  MOVWF  03
014BC:  MOVF   01,W
014BE:  ADDLW  20
014C0:  MOVWF  01
014C2:  MOVLW  00
014C4:  ADDWFC 03,F
014C6:  MOVFF  01,55E
014CA:  MOVFF  03,55F
014CE:  CLRF   x79
014D0:  MOVFF  55D,578
014D4:  CLRF   x7B
014D6:  MOVLW  18
014D8:  MOVWF  x7A
014DA:  MOVLB  0
014DC:  CALL   0492
014E0:  MOVFF  02,561
014E4:  MOVFF  01,560
014E8:  MOVLW  14
014EA:  MOVLB  5
014EC:  ADDWF  01,W
014EE:  MOVWF  01
014F0:  MOVLW  00
014F2:  ADDWFC 02,W
014F4:  MOVWF  03
014F6:  MOVF   01,W
014F8:  ADDLW  20
014FA:  MOVWF  FE9
014FC:  MOVLW  00
014FE:  ADDWFC 03,W
01500:  MOVWF  FEA
01502:  CLRF   x79
01504:  MOVFF  FEF,578
01508:  CLRF   x7B
0150A:  MOVLW  18
0150C:  MOVWF  x7A
0150E:  MOVLB  0
01510:  CALL   0492
01514:  MOVFF  01,560
01518:  MOVLW  01
0151A:  MOVLB  5
0151C:  ADDWF  01,W
0151E:  MOVWF  01
01520:  MOVLW  00
01522:  ADDWFC 02,W
01524:  MOVWF  03
01526:  MOVF   01,W
01528:  ADDLW  20
0152A:  MOVWF  FE9
0152C:  MOVLW  00
0152E:  ADDWFC 03,W
01530:  MOVWF  FEA
01532:  MOVFF  FEC,03
01536:  MOVF   FED,F
01538:  MOVF   FEF,W
0153A:  XORLW  FF
0153C:  ADDLW  DD
0153E:  MOVWF  x60
01540:  MOVLW  05
01542:  SUBFWB 03,W
01544:  MOVWF  x61
01546:  MOVLW  DC
01548:  ADDWF  x60,W
0154A:  MOVWF  01
0154C:  MOVLW  05
0154E:  ADDWFC x61,W
01550:  MOVFF  55F,FEA
01554:  MOVFF  55E,FE9
01558:  MOVWF  FEC
0155A:  MOVF   FED,F
0155C:  MOVFF  01,FEF
.................... 		  } 
.................... 		} 
....................  
.................... 	  if ( servo[i].mode == MODE_FOLLOW ) 
01560:  CLRF   x79
01562:  MOVFF  55D,578
01566:  CLRF   x7B
01568:  MOVLW  18
0156A:  MOVWF  x7A
0156C:  MOVLB  0
0156E:  CALL   0492
01572:  MOVFF  02,55F
01576:  MOVFF  01,55E
0157A:  MOVLW  20
0157C:  MOVLB  5
0157E:  ADDWF  01,W
01580:  MOVWF  FE9
01582:  MOVLW  00
01584:  ADDWFC 02,W
01586:  MOVWF  FEA
01588:  MOVF   FEF,W
0158A:  SUBLW  04
0158C:  BTFSS  FD8.2
0158E:  BRA    16D4
.................... 	    { 
.................... 		servo[i].pwDestination = servo[servo[i].master].pwCurrent; 
01590:  CLRF   x79
01592:  MOVFF  55D,578
01596:  CLRF   x7B
01598:  MOVLW  18
0159A:  MOVWF  x7A
0159C:  MOVLB  0
0159E:  CALL   0492
015A2:  MOVFF  01,55E
015A6:  MOVLW  03
015A8:  MOVLB  5
015AA:  ADDWF  01,W
015AC:  MOVWF  01
015AE:  MOVLW  00
015B0:  ADDWFC 02,W
015B2:  MOVWF  03
015B4:  MOVF   01,W
015B6:  ADDLW  20
015B8:  MOVWF  01
015BA:  MOVLW  00
015BC:  ADDWFC 03,F
015BE:  MOVFF  01,55E
015C2:  MOVFF  03,55F
015C6:  CLRF   x79
015C8:  MOVFF  55D,578
015CC:  CLRF   x7B
015CE:  MOVLW  18
015D0:  MOVWF  x7A
015D2:  MOVLB  0
015D4:  CALL   0492
015D8:  MOVFF  02,561
015DC:  MOVFF  01,560
015E0:  MOVLW  14
015E2:  MOVLB  5
015E4:  ADDWF  01,W
015E6:  MOVWF  01
015E8:  MOVLW  00
015EA:  ADDWFC 02,W
015EC:  MOVWF  03
015EE:  MOVF   01,W
015F0:  ADDLW  20
015F2:  MOVWF  FE9
015F4:  MOVLW  00
015F6:  ADDWFC 03,W
015F8:  MOVWF  FEA
015FA:  CLRF   x79
015FC:  MOVFF  FEF,578
01600:  CLRF   x7B
01602:  MOVLW  18
01604:  MOVWF  x7A
01606:  MOVLB  0
01608:  CALL   0492
0160C:  MOVFF  01,560
01610:  MOVLW  01
01612:  MOVLB  5
01614:  ADDWF  01,W
01616:  MOVWF  01
01618:  MOVLW  00
0161A:  ADDWFC 02,W
0161C:  MOVWF  03
0161E:  MOVF   01,W
01620:  ADDLW  20
01622:  MOVWF  FE9
01624:  MOVLW  00
01626:  ADDWFC 03,W
01628:  MOVWF  FEA
0162A:  MOVFF  FEC,03
0162E:  MOVF   FED,F
01630:  MOVFF  FEF,560
01634:  MOVFF  55F,FEA
01638:  MOVFF  55E,FE9
0163C:  MOVFF  03,FEC
01640:  MOVF   FED,F
01642:  MOVFF  560,FEF
.................... 	    servoUpdateStep(i); 
01646:  MOVFF  55D,55E
0164A:  MOVLB  0
0164C:  CALL   0BFC
.................... 	    servo[i].timeOut = servo[i].pwCurrent; 
01650:  MOVLB  5
01652:  CLRF   x79
01654:  MOVFF  55D,578
01658:  CLRF   x7B
0165A:  MOVLW  18
0165C:  MOVWF  x7A
0165E:  MOVLB  0
01660:  CALL   0492
01664:  MOVFF  01,55E
01668:  MOVLW  16
0166A:  MOVLB  5
0166C:  ADDWF  01,W
0166E:  MOVWF  01
01670:  MOVLW  00
01672:  ADDWFC 02,W
01674:  MOVWF  03
01676:  MOVF   01,W
01678:  ADDLW  20
0167A:  MOVWF  01
0167C:  MOVLW  00
0167E:  ADDWFC 03,F
01680:  MOVFF  01,55E
01684:  MOVFF  03,55F
01688:  CLRF   x79
0168A:  MOVFF  55D,578
0168E:  CLRF   x7B
01690:  MOVLW  18
01692:  MOVWF  x7A
01694:  MOVLB  0
01696:  CALL   0492
0169A:  MOVFF  01,560
0169E:  MOVLW  01
016A0:  MOVLB  5
016A2:  ADDWF  01,W
016A4:  MOVWF  01
016A6:  MOVLW  00
016A8:  ADDWFC 02,W
016AA:  MOVWF  03
016AC:  MOVF   01,W
016AE:  ADDLW  20
016B0:  MOVWF  FE9
016B2:  MOVLW  00
016B4:  ADDWFC 03,W
016B6:  MOVWF  FEA
016B8:  MOVFF  FEC,03
016BC:  MOVF   FED,F
016BE:  MOVFF  FEF,560
016C2:  MOVFF  55F,FEA
016C6:  MOVFF  55E,FE9
016CA:  MOVFF  03,FEC
016CE:  MOVF   FED,F
016D0:  MOVFF  560,FEF
.................... 		} 
.................... 	  } 
016D4:  INCF   x5D,F
016D6:  BRA    116C
....................  
.................... 	// apply offset 
.................... 	servo[i].timeOut = servo[i].timeOut + servo[i].offset; 
016D8:  CLRF   x79
016DA:  MOVFF  55D,578
016DE:  CLRF   x7B
016E0:  MOVLW  18
016E2:  MOVWF  x7A
016E4:  MOVLB  0
016E6:  CALL   0492
016EA:  MOVFF  01,55E
016EE:  MOVLW  16
016F0:  MOVLB  5
016F2:  ADDWF  01,W
016F4:  MOVWF  01
016F6:  MOVLW  00
016F8:  ADDWFC 02,W
016FA:  MOVWF  03
016FC:  MOVF   01,W
016FE:  ADDLW  20
01700:  MOVWF  01
01702:  MOVLW  00
01704:  ADDWFC 03,F
01706:  MOVFF  01,55E
0170A:  MOVFF  03,55F
0170E:  CLRF   x79
01710:  MOVFF  55D,578
01714:  CLRF   x7B
01716:  MOVLW  18
01718:  MOVWF  x7A
0171A:  MOVLB  0
0171C:  CALL   0492
01720:  MOVFF  01,560
01724:  MOVLW  16
01726:  MOVLB  5
01728:  ADDWF  01,W
0172A:  MOVWF  01
0172C:  MOVLW  00
0172E:  ADDWFC 02,W
01730:  MOVWF  03
01732:  MOVF   01,W
01734:  ADDLW  20
01736:  MOVWF  FE9
01738:  MOVLW  00
0173A:  ADDWFC 03,W
0173C:  MOVWF  FEA
0173E:  MOVFF  FEC,561
01742:  MOVF   FED,F
01744:  MOVFF  FEF,560
01748:  CLRF   x79
0174A:  MOVFF  55D,578
0174E:  CLRF   x7B
01750:  MOVLW  18
01752:  MOVWF  x7A
01754:  MOVLB  0
01756:  CALL   0492
0175A:  MOVFF  01,562
0175E:  MOVLW  08
01760:  MOVLB  5
01762:  ADDWF  01,W
01764:  MOVWF  01
01766:  MOVLW  00
01768:  ADDWFC 02,W
0176A:  MOVWF  03
0176C:  MOVF   01,W
0176E:  ADDLW  20
01770:  MOVWF  FE9
01772:  MOVLW  00
01774:  ADDWFC 03,W
01776:  MOVWF  FEA
01778:  MOVFF  FEC,03
0177C:  MOVF   FED,F
0177E:  MOVF   FEF,W
01780:  ADDWF  x60,W
01782:  MOVWF  01
01784:  MOVF   x61,W
01786:  ADDWFC 03,F
01788:  MOVFF  55F,FEA
0178C:  MOVFF  55E,FE9
01790:  MOVFF  03,FEC
01794:  MOVF   FED,F
01796:  MOVFF  01,FEF
.................... 	//servo[i].timeOut = servo[i].timeOut; // testing 
.................... } 
0179A:  MOVLB  0
0179C:  GOTO   3C68 (RETURN)
....................  
....................  
....................  
.................... // we area actualy just sorting an index as to the order to turn off the PW 
.................... void servoSort(void) 
.................... { 
.................... 	int8 i; 
.................... 	int8 ndx; 
.................... 	int8 flagSwap; 
....................  
.................... 	#ifdef DEBUG_MSG 
.................... 	  puts("servoSort()",debug); 
.................... 	#endif 
.................... 	 
.................... 	mServoLoop  
017A0:  MOVLB  5
017A2:  CLRF   x5D
017A4:  MOVF   x5D,W
017A6:  SUBLW  1F
017A8:  BNC   17C0
.................... 	  { 
.................... 	  sorted[i] = i; 
017AA:  CLRF   03
017AC:  MOVF   x5D,W
017AE:  ADDLW  20
017B0:  MOVWF  FE9
017B2:  MOVLW  03
017B4:  ADDWFC 03,W
017B6:  MOVWF  FEA
017B8:  MOVFF  55D,FEF
.................... 	  } 
017BC:  INCF   x5D,F
017BE:  BRA    17A4
....................  
.................... 	flagSwap = true; 
017C0:  MOVLW  01
017C2:  MOVWF  x5F
.................... 	while (flagSwap == true) 
.................... 	  { 
017C4:  DECFSZ x5F,W
017C6:  BRA    18D8
.................... 	  flagSwap = false; 
017C8:  CLRF   x5F
.................... 	  for (i=0; i<(MAX_SERVOS-1); i++)  
017CA:  CLRF   x5D
017CC:  MOVF   x5D,W
017CE:  SUBLW  1E
017D0:  BTFSS  FD8.0
017D2:  BRA    18D6
.................... 	    { 
.................... 	    if ( servo[sorted[i]].timeout > servo[sorted[i+1]].timeout ) 
017D4:  CLRF   03
017D6:  MOVF   x5D,W
017D8:  ADDLW  20
017DA:  MOVWF  FE9
017DC:  MOVLW  03
017DE:  ADDWFC 03,W
017E0:  MOVWF  FEA
017E2:  CLRF   x79
017E4:  MOVFF  FEF,578
017E8:  CLRF   x7B
017EA:  MOVLW  18
017EC:  MOVWF  x7A
017EE:  MOVLB  0
017F0:  CALL   0492
017F4:  MOVFF  01,560
017F8:  MOVLW  16
017FA:  MOVLB  5
017FC:  ADDWF  01,W
017FE:  MOVWF  01
01800:  MOVLW  00
01802:  ADDWFC 02,W
01804:  MOVWF  03
01806:  MOVF   01,W
01808:  ADDLW  20
0180A:  MOVWF  FE9
0180C:  MOVLW  00
0180E:  ADDWFC 03,W
01810:  MOVWF  FEA
01812:  MOVFF  FEC,561
01816:  MOVF   FED,F
01818:  MOVFF  FEF,560
0181C:  MOVLW  01
0181E:  ADDWF  x5D,W
01820:  CLRF   03
01822:  ADDLW  20
01824:  MOVWF  FE9
01826:  MOVLW  03
01828:  ADDWFC 03,W
0182A:  MOVWF  FEA
0182C:  CLRF   x79
0182E:  MOVFF  FEF,578
01832:  CLRF   x7B
01834:  MOVLW  18
01836:  MOVWF  x7A
01838:  MOVLB  0
0183A:  CALL   0492
0183E:  MOVFF  02,563
01842:  MOVFF  01,562
01846:  MOVLW  16
01848:  MOVLB  5
0184A:  ADDWF  01,W
0184C:  MOVWF  01
0184E:  MOVLW  00
01850:  ADDWFC 02,W
01852:  MOVWF  03
01854:  MOVF   01,W
01856:  ADDLW  20
01858:  MOVWF  FE9
0185A:  MOVLW  00
0185C:  ADDWFC 03,W
0185E:  MOVWF  FEA
01860:  MOVFF  FEC,03
01864:  MOVF   FED,F
01866:  MOVFF  FEF,01
0186A:  MOVF   03,W
0186C:  SUBWF  x61,W
0186E:  BNC   18D2
01870:  BNZ   1878
01872:  MOVF   x60,W
01874:  SUBWF  01,W
01876:  BC    18D2
.................... 	      { 
.................... 		  ndx = sorted[i]; 
01878:  CLRF   03
0187A:  MOVF   x5D,W
0187C:  ADDLW  20
0187E:  MOVWF  FE9
01880:  MOVLW  03
01882:  ADDWFC 03,W
01884:  MOVWF  FEA
01886:  MOVFF  FEF,55E
.................... 		  sorted[i] = sorted[i+1]; 
0188A:  CLRF   03
0188C:  MOVF   x5D,W
0188E:  ADDLW  20
01890:  MOVWF  01
01892:  MOVLW  03
01894:  ADDWFC 03,F
01896:  MOVFF  03,561
0189A:  MOVLW  01
0189C:  ADDWF  x5D,W
0189E:  CLRF   03
018A0:  ADDLW  20
018A2:  MOVWF  FE9
018A4:  MOVLW  03
018A6:  ADDWFC 03,W
018A8:  MOVWF  FEA
018AA:  MOVFF  FEF,562
018AE:  MOVFF  561,FEA
018B2:  MOVFF  01,FE9
018B6:  MOVFF  562,FEF
.................... 		  sorted[i+1] = ndx; 
018BA:  MOVLW  01
018BC:  ADDWF  x5D,W
018BE:  CLRF   03
018C0:  ADDLW  20
018C2:  MOVWF  FE9
018C4:  MOVLW  03
018C6:  ADDWFC 03,W
018C8:  MOVWF  FEA
018CA:  MOVFF  55E,FEF
.................... 		  flagSwap = true; 
018CE:  MOVLW  01
018D0:  MOVWF  x5F
.................... 		  } 
.................... 	    } 
018D2:  INCF   x5D,F
018D4:  BRA    17CC
.................... 	  } 
018D6:  BRA    17C4
....................  
.................... 	#ifdef DEBUG_MSG 
.................... 	  mServoLoop  
.................... 	    { 
.................... 	    //fprintf(debug,"S: %02i:%02i T:%Li\r\n",i,sorted[i],servo[sorted[i]].timeout); 
.................... 	    }	   
.................... 	#endif 
....................  
....................  
.................... } 
018D8:  MOVLB  0
018DA:  GOTO   3C6C (RETURN)
....................  
....................  
.................... // return the delta of two numbers 
.................... int16 retDelta(int16 a, int16 b) 
.................... { 
.................... 	int16 delta; 
....................  
.................... 	delta = 0; 
*
02C0C:  MOVLB  5
02C0E:  CLRF   x89
02C10:  CLRF   x88
....................  
.................... 	if (  a < b ) { 
02C12:  MOVF   x85,W
02C14:  SUBWF  x87,W
02C16:  BNC   2C2C
02C18:  BNZ   2C20
02C1A:  MOVF   x86,W
02C1C:  SUBWF  x84,W
02C1E:  BC    2C2C
.................... 	  delta = b-a; 
02C20:  MOVF   x84,W
02C22:  SUBWF  x86,W
02C24:  MOVWF  x88
02C26:  MOVF   x85,W
02C28:  SUBWFB x87,W
02C2A:  MOVWF  x89
.................... 	  } 
....................  
.................... 	if (  b < a ) { 
02C2C:  MOVF   x87,W
02C2E:  SUBWF  x85,W
02C30:  BNC   2C46
02C32:  BNZ   2C3A
02C34:  MOVF   x84,W
02C36:  SUBWF  x86,W
02C38:  BC    2C46
.................... 	  delta = a-b; 
02C3A:  MOVF   x86,W
02C3C:  SUBWF  x84,W
02C3E:  MOVWF  x88
02C40:  MOVF   x87,W
02C42:  SUBWFB x85,W
02C44:  MOVWF  x89
.................... 	  } 
....................  
.................... 	return delta; 
02C46:  MOVFF  588,01
02C4A:  MOVFF  589,02
....................  
.................... } 
02C4E:  MOVLB  0
02C50:  GOTO   2CCA (RETURN)
....................  
.................... // returns the step rate to complete a move over time 
.................... int16 retStepOverTime(int16 c, int16 d, int16 time) 
.................... { 
.................... 	int16 factor; 
.................... 	int16 res; 
.................... 	 
.................... 	factor = time / MS_FRAME; 
*
02C9C:  MOVLB  5
02C9E:  RRCF   x7F,W
02CA0:  MOVWF  x81
02CA2:  RRCF   x7E,W
02CA4:  MOVWF  x80
02CA6:  RRCF   x81,F
02CA8:  RRCF   x80,F
02CAA:  RRCF   x81,F
02CAC:  RRCF   x80,F
02CAE:  RRCF   x81,F
02CB0:  RRCF   x80,F
02CB2:  MOVLW  0F
02CB4:  ANDWF  x81,F
.................... 	res = retDelta(c,d) / factor; 
02CB6:  MOVFF  57B,585
02CBA:  MOVFF  57A,584
02CBE:  MOVFF  57D,587
02CC2:  MOVFF  57C,586
02CC6:  MOVLB  0
02CC8:  BRA    2C0C
02CCA:  MOVFF  02,585
02CCE:  MOVFF  01,584
02CD2:  MOVFF  02,587
02CD6:  MOVFF  01,586
02CDA:  MOVFF  581,589
02CDE:  MOVFF  580,588
02CE2:  BRA    2C54
02CE4:  MOVFF  02,583
02CE8:  MOVFF  01,582
.................... 	return res; 
02CEC:  MOVLB  5
02CEE:  MOVFF  582,01
02CF2:  MOVFF  583,02
.................... } 
02CF6:  MOVLB  0
02CF8:  GOTO   30F4 (RETURN)
....................  
.................... #include "error.c" 
.................... /* 
....................           file: error.c 
....................        project: SSX32  
....................    description: error status on the led 
....................  
....................    Changelog: 
....................       01/31/11 This file created 
....................  
....................  
.................... */ 
....................  
.................... void error_serOverflow(void) 
.................... { 
.................... 	mForever 
.................... 	  { 
.................... 	  mLED(PW_LED,OFF); 
*
00152:  BCF    F8B.5
00154:  BCF    F94.5
.................... 	  delay_ms(100); 
00156:  MOVLW  64
00158:  MOVLB  5
0015A:  MOVWF  xC3
0015C:  MOVLB  0
0015E:  RCALL  0128
.................... 	  mLED(PW_LED,ON); 
00160:  BSF    F8B.5
00162:  BCF    F94.5
.................... 	  delay_ms(100); 
00164:  MOVLW  64
00166:  MOVLB  5
00168:  MOVWF  xC3
0016A:  MOVLB  0
0016C:  RCALL  0128
.................... 	  } 
0016E:  BRA    0152
.................... } 
00170:  GOTO   01D2 (RETURN)
....................  
.................... #include "eeprom.c" 
.................... /* 
....................           file: eeprom.c 
....................        project: SSX32  
....................    description: eeprom related code 
....................  
....................    Changelog: 
....................       01/15/11 I put eeprom related defines here so the defines.h file 
.................... 				doesnt grow to big 
....................  
....................  
.................... */ 
....................  
....................  
.................... // eeprom related defines 
.................... #define EE_FIRSTUSE		0		// pointer to first use byte 
.................... #define	EE_BASE_HOME	32		// base address for servo home 
.................... #define	EE_BASE_OFFSET	64		// base address for servo home 
.................... #define EE_BASE_MIN		96		// base address for servo min 
.................... #define EE_BASE_MAX		128		// base address for servo max 
....................  
....................  
.................... int16 ee_readHomePW(int8 wServo) 
.................... { 
.................... 	int16 addr; 
.................... 	addr = EE_BASE_HOME + (wServo * 2); 
*
00532:  BCF    FD8.0
00534:  MOVLB  5
00536:  RLCF   x60,W
00538:  ADDLW  20
0053A:  MOVWF  x61
0053C:  CLRF   x62
.................... 	return read_eeprom(addr) + ( read_eeprom(addr + 1) * 256 ); 
0053E:  MOVFF  FF2,563
00542:  BCF    FF2.7
00544:  MOVFF  562,FAA
00548:  MOVFF  561,FA9
0054C:  BCF    FA6.6
0054E:  BCF    FA6.7
00550:  BSF    FA6.0
00552:  MOVF   FA8,W
00554:  BTFSC  x63.7
00556:  BSF    FF2.7
00558:  MOVWF  x64
0055A:  MOVLW  01
0055C:  ADDWF  x61,W
0055E:  MOVWF  x65
00560:  MOVLW  00
00562:  ADDWFC x62,W
00564:  MOVWF  x66
00566:  MOVFF  FF2,567
0056A:  BCF    FF2.7
0056C:  MOVFF  566,FAA
00570:  MOVFF  565,FA9
00574:  BCF    FA6.6
00576:  BCF    FA6.7
00578:  BSF    FA6.0
0057A:  MOVF   FA8,W
0057C:  BTFSC  x67.7
0057E:  BSF    FF2.7
00580:  MOVWF  x66
00582:  CLRF   x79
00584:  MOVFF  566,578
00588:  MOVLW  01
0058A:  MOVWF  x7B
0058C:  CLRF   x7A
0058E:  MOVLB  0
00590:  RCALL  0492
00592:  MOVFF  02,03
00596:  MOVF   01,W
00598:  MOVLB  5
0059A:  ADDWF  x64,W
0059C:  MOVWF  01
0059E:  MOVLW  00
005A0:  ADDWFC 03,F
005A2:  MOVF   01,W
005A4:  MOVWF  01
005A6:  MOVF   03,W
005A8:  MOVWF  02
.................... } 
005AA:  MOVLB  0
005AC:  GOTO   0794 (RETURN)
....................  
.................... void ee_writeHomePW(int8 wServo, int16 wVal) 
.................... { 
.................... 	int16 addr; 
.................... 	int8 lo, hi; 
....................  
.................... 	addr = EE_BASE_HOME + (wServo * 2); 
*
001E4:  BCF    FD8.0
001E6:  MOVLB  5
001E8:  RLCF   x60,W
001EA:  ADDLW  20
001EC:  MOVWF  x63
001EE:  CLRF   x64
....................  
.................... 	lo = wVal & 0x00FF; 
001F0:  MOVFF  561,565
.................... 	hi = wVal >> 8; 
001F4:  MOVFF  562,566
.................... 	hi = hi & 0x00FF; 
....................  
.................... 	write_eeprom(addr, lo); 
001F8:  MOVFF  564,FAA
001FC:  MOVFF  563,FA9
00200:  MOVFF  565,FA8
00204:  BCF    FA6.6
00206:  BCF    FA6.7
00208:  BSF    FA6.2
0020A:  MOVF   FF2,W
0020C:  MOVWF  00
0020E:  BCF    FF2.7
00210:  MOVLB  F
00212:  MOVLW  55
00214:  MOVWF  FA7
00216:  MOVLW  AA
00218:  MOVWF  FA7
0021A:  BSF    FA6.1
0021C:  BTFSC  FA6.1
0021E:  BRA    021C
00220:  BCF    FA6.2
00222:  MOVF   00,W
00224:  IORWF  FF2,F
....................     write_eeprom(addr + 1, hi); 
00226:  MOVLW  01
00228:  MOVLB  5
0022A:  ADDWF  x63,W
0022C:  MOVWF  x67
0022E:  MOVLW  00
00230:  ADDWFC x64,W
00232:  MOVWF  x68
00234:  MOVFF  568,FAA
00238:  MOVFF  567,FA9
0023C:  MOVFF  566,FA8
00240:  BCF    FA6.6
00242:  BCF    FA6.7
00244:  BSF    FA6.2
00246:  MOVF   FF2,W
00248:  MOVWF  00
0024A:  BCF    FF2.7
0024C:  MOVLB  F
0024E:  MOVLW  55
00250:  MOVWF  FA7
00252:  MOVLW  AA
00254:  MOVWF  FA7
00256:  BSF    FA6.1
00258:  BTFSC  FA6.1
0025A:  BRA    0258
0025C:  BCF    FA6.2
0025E:  MOVF   00,W
00260:  IORWF  FF2,F
.................... } 
00262:  MOVLB  0
00264:  RETLW  00
....................  
....................  
....................  
.................... int16 ee_readOffsetPW(int8 wServo) 
.................... { 
.................... 	int16 addr; 
.................... 	addr = EE_BASE_OFFSET + (wServo * 2); 
*
004B4:  BCF    FD8.0
004B6:  MOVLB  5
004B8:  RLCF   x60,W
004BA:  ADDLW  40
004BC:  MOVWF  x61
004BE:  CLRF   x62
.................... 	return read_eeprom(addr) + ( read_eeprom(addr + 1) * 256 ); 
004C0:  MOVFF  FF2,563
004C4:  BCF    FF2.7
004C6:  MOVFF  562,FAA
004CA:  MOVFF  561,FA9
004CE:  BCF    FA6.6
004D0:  BCF    FA6.7
004D2:  BSF    FA6.0
004D4:  MOVF   FA8,W
004D6:  BTFSC  x63.7
004D8:  BSF    FF2.7
004DA:  MOVWF  x64
004DC:  MOVLW  01
004DE:  ADDWF  x61,W
004E0:  MOVWF  x65
004E2:  MOVLW  00
004E4:  ADDWFC x62,W
004E6:  MOVWF  x66
004E8:  MOVFF  FF2,567
004EC:  BCF    FF2.7
004EE:  MOVFF  566,FAA
004F2:  MOVFF  565,FA9
004F6:  BCF    FA6.6
004F8:  BCF    FA6.7
004FA:  BSF    FA6.0
004FC:  MOVF   FA8,W
004FE:  BTFSC  x67.7
00500:  BSF    FF2.7
00502:  MOVWF  x66
00504:  CLRF   x79
00506:  MOVFF  566,578
0050A:  MOVLW  01
0050C:  MOVWF  x7B
0050E:  CLRF   x7A
00510:  MOVLB  0
00512:  RCALL  0492
00514:  MOVFF  02,03
00518:  MOVF   01,W
0051A:  MOVLB  5
0051C:  ADDWF  x64,W
0051E:  MOVWF  01
00520:  MOVLW  00
00522:  ADDWFC 03,F
00524:  MOVF   01,W
00526:  MOVWF  01
00528:  MOVF   03,W
0052A:  MOVWF  02
.................... } 
0052C:  MOVLB  0
0052E:  GOTO   0744 (RETURN)
....................  
.................... void ee_writeOffsetPW(int8 wServo, int16 wVal) 
.................... { 
.................... 	int16 addr; 
.................... 	int8 lo, hi; 
....................  
.................... 	addr = EE_BASE_OFFSET + (wServo * 2); 
*
00266:  BCF    FD8.0
00268:  MOVLB  5
0026A:  RLCF   x60,W
0026C:  ADDLW  40
0026E:  MOVWF  x63
00270:  CLRF   x64
....................  
.................... 	lo = wVal & 0x00FF; 
00272:  MOVFF  561,565
.................... 	hi = wVal >> 8; 
00276:  MOVFF  562,566
.................... 	hi = hi & 0x00FF; 
....................  
.................... 	write_eeprom(addr, lo); 
0027A:  MOVFF  564,FAA
0027E:  MOVFF  563,FA9
00282:  MOVFF  565,FA8
00286:  BCF    FA6.6
00288:  BCF    FA6.7
0028A:  BSF    FA6.2
0028C:  MOVF   FF2,W
0028E:  MOVWF  00
00290:  BCF    FF2.7
00292:  MOVLB  F
00294:  MOVLW  55
00296:  MOVWF  FA7
00298:  MOVLW  AA
0029A:  MOVWF  FA7
0029C:  BSF    FA6.1
0029E:  BTFSC  FA6.1
002A0:  BRA    029E
002A2:  BCF    FA6.2
002A4:  MOVF   00,W
002A6:  IORWF  FF2,F
....................     write_eeprom(addr + 1, hi); 
002A8:  MOVLW  01
002AA:  MOVLB  5
002AC:  ADDWF  x63,W
002AE:  MOVWF  x67
002B0:  MOVLW  00
002B2:  ADDWFC x64,W
002B4:  MOVWF  x68
002B6:  MOVFF  568,FAA
002BA:  MOVFF  567,FA9
002BE:  MOVFF  566,FA8
002C2:  BCF    FA6.6
002C4:  BCF    FA6.7
002C6:  BSF    FA6.2
002C8:  MOVF   FF2,W
002CA:  MOVWF  00
002CC:  BCF    FF2.7
002CE:  MOVLB  F
002D0:  MOVLW  55
002D2:  MOVWF  FA7
002D4:  MOVLW  AA
002D6:  MOVWF  FA7
002D8:  BSF    FA6.1
002DA:  BTFSC  FA6.1
002DC:  BRA    02DA
002DE:  BCF    FA6.2
002E0:  MOVF   00,W
002E2:  IORWF  FF2,F
.................... } 
002E4:  MOVLB  0
002E6:  RETLW  00
....................  
....................  
.................... int16 ee_readMinPW(int8 wServo) 
.................... { 
.................... 	int16 addr; 
.................... 	addr = EE_BASE_MIN + (wServo * 2); 
.................... 	return read_eeprom(addr) + ( read_eeprom(addr + 1) * 256 ); 
.................... } 
....................  
.................... void ee_writeMinPW(int8 wServo, int16 wVal) 
.................... { 
.................... 	int16 addr; 
.................... 	int8 lo, hi; 
....................  
.................... 	addr = EE_BASE_MIN + (wServo * 2); 
002E8:  BCF    FD8.0
002EA:  MOVLB  5
002EC:  RLCF   x60,W
002EE:  ADDLW  60
002F0:  MOVWF  x63
002F2:  CLRF   x64
....................  
.................... 	lo = wVal & 0x00FF; 
002F4:  MOVFF  561,565
.................... 	hi = wVal >> 8; 
002F8:  MOVFF  562,566
.................... 	hi = hi & 0x00FF; 
....................  
.................... 	write_eeprom(addr, lo); 
002FC:  MOVFF  564,FAA
00300:  MOVFF  563,FA9
00304:  MOVFF  565,FA8
00308:  BCF    FA6.6
0030A:  BCF    FA6.7
0030C:  BSF    FA6.2
0030E:  MOVF   FF2,W
00310:  MOVWF  00
00312:  BCF    FF2.7
00314:  MOVLB  F
00316:  MOVLW  55
00318:  MOVWF  FA7
0031A:  MOVLW  AA
0031C:  MOVWF  FA7
0031E:  BSF    FA6.1
00320:  BTFSC  FA6.1
00322:  BRA    0320
00324:  BCF    FA6.2
00326:  MOVF   00,W
00328:  IORWF  FF2,F
....................     write_eeprom(addr + 1, hi); 
0032A:  MOVLW  01
0032C:  MOVLB  5
0032E:  ADDWF  x63,W
00330:  MOVWF  x67
00332:  MOVLW  00
00334:  ADDWFC x64,W
00336:  MOVWF  x68
00338:  MOVFF  568,FAA
0033C:  MOVFF  567,FA9
00340:  MOVFF  566,FA8
00344:  BCF    FA6.6
00346:  BCF    FA6.7
00348:  BSF    FA6.2
0034A:  MOVF   FF2,W
0034C:  MOVWF  00
0034E:  BCF    FF2.7
00350:  MOVLB  F
00352:  MOVLW  55
00354:  MOVWF  FA7
00356:  MOVLW  AA
00358:  MOVWF  FA7
0035A:  BSF    FA6.1
0035C:  BTFSC  FA6.1
0035E:  BRA    035C
00360:  BCF    FA6.2
00362:  MOVF   00,W
00364:  IORWF  FF2,F
.................... } 
00366:  MOVLB  0
00368:  RETLW  00
....................  
....................  
.................... int16 ee_readMaxPW(int8 wServo) 
.................... { 
.................... 	int16 addr; 
.................... 	addr = EE_BASE_MAX + (wServo * 2); 
.................... 	return read_eeprom(addr) + ( read_eeprom(addr + 1) * 256 ); 
.................... } 
....................  
.................... void ee_writeMaxPW(int8 wServo, int16 wVal) 
.................... { 
.................... 	int16 addr; 
.................... 	int8 lo, hi; 
....................  
.................... 	addr = EE_BASE_MAX + (wServo * 2); 
0036A:  BCF    FD8.0
0036C:  MOVLB  5
0036E:  RLCF   x60,W
00370:  ADDLW  80
00372:  MOVWF  x63
00374:  CLRF   x64
....................  
.................... 	lo = wVal & 0x00FF; 
00376:  MOVFF  561,565
.................... 	hi = wVal >> 8; 
0037A:  MOVFF  562,566
.................... 	hi = hi & 0x00FF; 
....................  
.................... 	write_eeprom(addr, lo); 
0037E:  MOVFF  564,FAA
00382:  MOVFF  563,FA9
00386:  MOVFF  565,FA8
0038A:  BCF    FA6.6
0038C:  BCF    FA6.7
0038E:  BSF    FA6.2
00390:  MOVF   FF2,W
00392:  MOVWF  00
00394:  BCF    FF2.7
00396:  MOVLB  F
00398:  MOVLW  55
0039A:  MOVWF  FA7
0039C:  MOVLW  AA
0039E:  MOVWF  FA7
003A0:  BSF    FA6.1
003A2:  BTFSC  FA6.1
003A4:  BRA    03A2
003A6:  BCF    FA6.2
003A8:  MOVF   00,W
003AA:  IORWF  FF2,F
....................     write_eeprom(addr + 1, hi); 
003AC:  MOVLW  01
003AE:  MOVLB  5
003B0:  ADDWF  x63,W
003B2:  MOVWF  x67
003B4:  MOVLW  00
003B6:  ADDWFC x64,W
003B8:  MOVWF  x68
003BA:  MOVFF  568,FAA
003BE:  MOVFF  567,FA9
003C2:  MOVFF  566,FA8
003C6:  BCF    FA6.6
003C8:  BCF    FA6.7
003CA:  BSF    FA6.2
003CC:  MOVF   FF2,W
003CE:  MOVWF  00
003D0:  BCF    FF2.7
003D2:  MOVLB  F
003D4:  MOVLW  55
003D6:  MOVWF  FA7
003D8:  MOVLW  AA
003DA:  MOVWF  FA7
003DC:  BSF    FA6.1
003DE:  BTFSC  FA6.1
003E0:  BRA    03DE
003E2:  BCF    FA6.2
003E4:  MOVF   00,W
003E6:  IORWF  FF2,F
.................... } 
003E8:  MOVLB  0
003EA:  RETLW  00
....................  
....................  
....................  
.................... // this writes any servo data to eeprom if needed 
.................... void ee_writeServoData(void) 
.................... { 
.................... 	int8 i; 
.................... 	#ifdef DEBUG_MSG 
.................... 	  puts("ee_writeServoData()",debug); 
.................... 	#endif 
.................... 	mServoLoop 
*
0391E:  MOVLB  5
03920:  CLRF   x5D
03922:  MOVF   x5D,W
03924:  SUBLW  1F
03926:  BTFSS  FD8.0
03928:  BRA    3C0E
.................... 	  { 
....................  
.................... 	  if (servo[i].writeOffset == true) { 
0392A:  CLRF   x79
0392C:  MOVFF  55D,578
03930:  CLRF   x7B
03932:  MOVLW  18
03934:  MOVWF  x7A
03936:  MOVLB  0
03938:  CALL   0492
0393C:  MOVFF  02,55F
03940:  MOVFF  01,55E
03944:  MOVLW  10
03946:  MOVLB  5
03948:  ADDWF  01,W
0394A:  MOVWF  01
0394C:  MOVLW  00
0394E:  ADDWFC 02,W
03950:  MOVWF  03
03952:  MOVF   01,W
03954:  ADDLW  20
03956:  MOVWF  FE9
03958:  MOVLW  00
0395A:  ADDWFC 03,W
0395C:  MOVWF  FEA
0395E:  DECFSZ FEF,W
03960:  BRA    39E2
.................... 	    ee_writeOffsetPW(i,servo[i].offset); 
03962:  CLRF   x79
03964:  MOVFF  55D,578
03968:  CLRF   x7B
0396A:  MOVLW  18
0396C:  MOVWF  x7A
0396E:  MOVLB  0
03970:  CALL   0492
03974:  MOVFF  01,55E
03978:  MOVLW  08
0397A:  MOVLB  5
0397C:  ADDWF  01,W
0397E:  MOVWF  01
03980:  MOVLW  00
03982:  ADDWFC 02,W
03984:  MOVWF  03
03986:  MOVF   01,W
03988:  ADDLW  20
0398A:  MOVWF  FE9
0398C:  MOVLW  00
0398E:  ADDWFC 03,W
03990:  MOVWF  FEA
03992:  MOVFF  FEC,55F
03996:  MOVF   FED,F
03998:  MOVFF  FEF,55E
0399C:  MOVFF  55D,560
039A0:  MOVFF  55F,562
039A4:  MOVFF  55E,561
039A8:  MOVLB  0
039AA:  CALL   0266
.................... 	    servo[i].writeOffset = false;  
039AE:  MOVLB  5
039B0:  CLRF   x79
039B2:  MOVFF  55D,578
039B6:  CLRF   x7B
039B8:  MOVLW  18
039BA:  MOVWF  x7A
039BC:  MOVLB  0
039BE:  CALL   0492
039C2:  MOVFF  01,55E
039C6:  MOVLW  10
039C8:  MOVLB  5
039CA:  ADDWF  01,W
039CC:  MOVWF  01
039CE:  MOVLW  00
039D0:  ADDWFC 02,W
039D2:  MOVWF  03
039D4:  MOVF   01,W
039D6:  ADDLW  20
039D8:  MOVWF  FE9
039DA:  MOVLW  00
039DC:  ADDWFC 03,W
039DE:  MOVWF  FEA
039E0:  CLRF   FEF
.................... 		} 
....................  
.................... 	  if (servo[i].writeHome == true) { 
039E2:  CLRF   x79
039E4:  MOVFF  55D,578
039E8:  CLRF   x7B
039EA:  MOVLW  18
039EC:  MOVWF  x7A
039EE:  MOVLB  0
039F0:  CALL   0492
039F4:  MOVFF  02,55F
039F8:  MOVFF  01,55E
039FC:  MOVLW  11
039FE:  MOVLB  5
03A00:  ADDWF  01,W
03A02:  MOVWF  01
03A04:  MOVLW  00
03A06:  ADDWFC 02,W
03A08:  MOVWF  03
03A0A:  MOVF   01,W
03A0C:  ADDLW  20
03A0E:  MOVWF  FE9
03A10:  MOVLW  00
03A12:  ADDWFC 03,W
03A14:  MOVWF  FEA
03A16:  DECFSZ FEF,W
03A18:  BRA    3A9A
.................... 	    ee_writeHomePW(i,servo[i].home); 
03A1A:  CLRF   x79
03A1C:  MOVFF  55D,578
03A20:  CLRF   x7B
03A22:  MOVLW  18
03A24:  MOVWF  x7A
03A26:  MOVLB  0
03A28:  CALL   0492
03A2C:  MOVFF  01,55E
03A30:  MOVLW  0A
03A32:  MOVLB  5
03A34:  ADDWF  01,W
03A36:  MOVWF  01
03A38:  MOVLW  00
03A3A:  ADDWFC 02,W
03A3C:  MOVWF  03
03A3E:  MOVF   01,W
03A40:  ADDLW  20
03A42:  MOVWF  FE9
03A44:  MOVLW  00
03A46:  ADDWFC 03,W
03A48:  MOVWF  FEA
03A4A:  MOVFF  FEC,55F
03A4E:  MOVF   FED,F
03A50:  MOVFF  FEF,55E
03A54:  MOVFF  55D,560
03A58:  MOVFF  55F,562
03A5C:  MOVFF  55E,561
03A60:  MOVLB  0
03A62:  CALL   01E4
.................... 	    servo[i].writeHome = false;  
03A66:  MOVLB  5
03A68:  CLRF   x79
03A6A:  MOVFF  55D,578
03A6E:  CLRF   x7B
03A70:  MOVLW  18
03A72:  MOVWF  x7A
03A74:  MOVLB  0
03A76:  CALL   0492
03A7A:  MOVFF  01,55E
03A7E:  MOVLW  11
03A80:  MOVLB  5
03A82:  ADDWF  01,W
03A84:  MOVWF  01
03A86:  MOVLW  00
03A88:  ADDWFC 02,W
03A8A:  MOVWF  03
03A8C:  MOVF   01,W
03A8E:  ADDLW  20
03A90:  MOVWF  FE9
03A92:  MOVLW  00
03A94:  ADDWFC 03,W
03A96:  MOVWF  FEA
03A98:  CLRF   FEF
.................... 		} 
....................  
.................... 	  if (servo[i].writeMin == true) { 
03A9A:  CLRF   x79
03A9C:  MOVFF  55D,578
03AA0:  CLRF   x7B
03AA2:  MOVLW  18
03AA4:  MOVWF  x7A
03AA6:  MOVLB  0
03AA8:  CALL   0492
03AAC:  MOVFF  02,55F
03AB0:  MOVFF  01,55E
03AB4:  MOVLW  12
03AB6:  MOVLB  5
03AB8:  ADDWF  01,W
03ABA:  MOVWF  01
03ABC:  MOVLW  00
03ABE:  ADDWFC 02,W
03AC0:  MOVWF  03
03AC2:  MOVF   01,W
03AC4:  ADDLW  20
03AC6:  MOVWF  FE9
03AC8:  MOVLW  00
03ACA:  ADDWFC 03,W
03ACC:  MOVWF  FEA
03ACE:  DECFSZ FEF,W
03AD0:  BRA    3B52
.................... 	    ee_writeMinPW(i,servo[i].min); 
03AD2:  CLRF   x79
03AD4:  MOVFF  55D,578
03AD8:  CLRF   x7B
03ADA:  MOVLW  18
03ADC:  MOVWF  x7A
03ADE:  MOVLB  0
03AE0:  CALL   0492
03AE4:  MOVFF  01,55E
03AE8:  MOVLW  0C
03AEA:  MOVLB  5
03AEC:  ADDWF  01,W
03AEE:  MOVWF  01
03AF0:  MOVLW  00
03AF2:  ADDWFC 02,W
03AF4:  MOVWF  03
03AF6:  MOVF   01,W
03AF8:  ADDLW  20
03AFA:  MOVWF  FE9
03AFC:  MOVLW  00
03AFE:  ADDWFC 03,W
03B00:  MOVWF  FEA
03B02:  MOVFF  FEC,55F
03B06:  MOVF   FED,F
03B08:  MOVFF  FEF,55E
03B0C:  MOVFF  55D,560
03B10:  MOVFF  55F,562
03B14:  MOVFF  55E,561
03B18:  MOVLB  0
03B1A:  CALL   02E8
.................... 	    servo[i].writeMin = false;  
03B1E:  MOVLB  5
03B20:  CLRF   x79
03B22:  MOVFF  55D,578
03B26:  CLRF   x7B
03B28:  MOVLW  18
03B2A:  MOVWF  x7A
03B2C:  MOVLB  0
03B2E:  CALL   0492
03B32:  MOVFF  01,55E
03B36:  MOVLW  12
03B38:  MOVLB  5
03B3A:  ADDWF  01,W
03B3C:  MOVWF  01
03B3E:  MOVLW  00
03B40:  ADDWFC 02,W
03B42:  MOVWF  03
03B44:  MOVF   01,W
03B46:  ADDLW  20
03B48:  MOVWF  FE9
03B4A:  MOVLW  00
03B4C:  ADDWFC 03,W
03B4E:  MOVWF  FEA
03B50:  CLRF   FEF
.................... 		} 
....................  
.................... 	  if (servo[i].writeMax == true) { 
03B52:  CLRF   x79
03B54:  MOVFF  55D,578
03B58:  CLRF   x7B
03B5A:  MOVLW  18
03B5C:  MOVWF  x7A
03B5E:  MOVLB  0
03B60:  CALL   0492
03B64:  MOVFF  02,55F
03B68:  MOVFF  01,55E
03B6C:  MOVLW  13
03B6E:  MOVLB  5
03B70:  ADDWF  01,W
03B72:  MOVWF  01
03B74:  MOVLW  00
03B76:  ADDWFC 02,W
03B78:  MOVWF  03
03B7A:  MOVF   01,W
03B7C:  ADDLW  20
03B7E:  MOVWF  FE9
03B80:  MOVLW  00
03B82:  ADDWFC 03,W
03B84:  MOVWF  FEA
03B86:  DECFSZ FEF,W
03B88:  BRA    3C0A
.................... 	    ee_writeMaxPW(i,servo[i].max); 
03B8A:  CLRF   x79
03B8C:  MOVFF  55D,578
03B90:  CLRF   x7B
03B92:  MOVLW  18
03B94:  MOVWF  x7A
03B96:  MOVLB  0
03B98:  CALL   0492
03B9C:  MOVFF  01,55E
03BA0:  MOVLW  0E
03BA2:  MOVLB  5
03BA4:  ADDWF  01,W
03BA6:  MOVWF  01
03BA8:  MOVLW  00
03BAA:  ADDWFC 02,W
03BAC:  MOVWF  03
03BAE:  MOVF   01,W
03BB0:  ADDLW  20
03BB2:  MOVWF  FE9
03BB4:  MOVLW  00
03BB6:  ADDWFC 03,W
03BB8:  MOVWF  FEA
03BBA:  MOVFF  FEC,55F
03BBE:  MOVF   FED,F
03BC0:  MOVFF  FEF,55E
03BC4:  MOVFF  55D,560
03BC8:  MOVFF  55F,562
03BCC:  MOVFF  55E,561
03BD0:  MOVLB  0
03BD2:  CALL   036A
.................... 	    servo[i].writeMax = false;  
03BD6:  MOVLB  5
03BD8:  CLRF   x79
03BDA:  MOVFF  55D,578
03BDE:  CLRF   x7B
03BE0:  MOVLW  18
03BE2:  MOVWF  x7A
03BE4:  MOVLB  0
03BE6:  CALL   0492
03BEA:  MOVFF  01,55E
03BEE:  MOVLW  13
03BF0:  MOVLB  5
03BF2:  ADDWF  01,W
03BF4:  MOVWF  01
03BF6:  MOVLW  00
03BF8:  ADDWFC 02,W
03BFA:  MOVWF  03
03BFC:  MOVF   01,W
03BFE:  ADDLW  20
03C00:  MOVWF  FE9
03C02:  MOVLW  00
03C04:  ADDWFC 03,W
03C06:  MOVWF  FEA
03C08:  CLRF   FEF
.................... 		} 
....................  
.................... 	  } 
03C0A:  INCF   x5D,F
03C0C:  BRA    3922
....................  
.................... } 
03C0E:  MOVLB  0
03C10:  GOTO   3C94 (RETURN)
....................  
.................... #include "firstuse.c" 
.................... /* 
....................           file: firstuse.c 
....................        project: SSX32  
....................    description: setup eeprom for first use 
....................  
....................    Changelog: 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
....................  
....................  
....................  
....................  
.................... void setupFirstUse(void) 
.................... { 
.................... 	int8 i; 
.................... 	write_eeprom(EE_FIRSTUSE, 1); 
*
003EC:  CLRF   FAA
003EE:  CLRF   FA9
003F0:  MOVLW  01
003F2:  MOVWF  FA8
003F4:  BCF    FA6.6
003F6:  BCF    FA6.7
003F8:  BSF    FA6.2
003FA:  MOVF   FF2,W
003FC:  MOVWF  00
003FE:  BCF    FF2.7
00400:  MOVLB  F
00402:  MOVLW  55
00404:  MOVWF  FA7
00406:  MOVLW  AA
00408:  MOVWF  FA7
0040A:  BSF    FA6.1
0040C:  BTFSC  FA6.1
0040E:  BRA    040C
00410:  BCF    FA6.2
00412:  MOVF   00,W
00414:  IORWF  FF2,F
.................... 	#ifdef DEBUG_MSG 
.................... 	  puts("setupFirstUse()",debug); 
.................... 	#endif 
.................... 	mServoLoop 
00416:  MOVLB  5
00418:  CLRF   x5E
0041A:  MOVF   x5E,W
0041C:  SUBLW  1F
0041E:  BNC   0464
.................... 	  { 
.................... 	  ee_writeHomePW(i,0); 
00420:  MOVFF  55E,560
00424:  CLRF   x62
00426:  CLRF   x61
00428:  MOVLB  0
0042A:  RCALL  01E4
.................... 	  ee_writeOffsetPW(i,0); 
0042C:  MOVFF  55E,560
00430:  MOVLB  5
00432:  CLRF   x62
00434:  CLRF   x61
00436:  MOVLB  0
00438:  RCALL  0266
.................... 	  ee_writeMinPW(i,PW_MIN); 
0043A:  MOVFF  55E,560
0043E:  MOVLW  03
00440:  MOVLB  5
00442:  MOVWF  x62
00444:  MOVLW  20
00446:  MOVWF  x61
00448:  MOVLB  0
0044A:  RCALL  02E8
.................... 	  ee_writeMaxPW(i,PW_MAX); 
0044C:  MOVFF  55E,560
00450:  MOVLW  08
00452:  MOVLB  5
00454:  MOVWF  x62
00456:  MOVLW  98
00458:  MOVWF  x61
0045A:  MOVLB  0
0045C:  RCALL  036A
.................... 	  } 
0045E:  MOVLB  5
00460:  INCF   x5E,F
00462:  BRA    041A
.................... } 
00464:  MOVLB  0
00466:  GOTO   048A (RETURN)
....................  
....................  
.................... void firstUse(void) 
.................... { 
.................... 	if ( read_eeprom(EE_FIRSTUSE) == 0xFF ) { 
0046A:  MOVFF  FF2,55E
0046E:  BCF    FF2.7
00470:  CLRF   FAA
00472:  CLRF   FA9
00474:  BCF    FA6.6
00476:  BCF    FA6.7
00478:  BSF    FA6.0
0047A:  MOVF   FA8,W
0047C:  MOVLB  5
0047E:  BTFSC  x5E.7
00480:  BSF    FF2.7
00482:  SUBLW  FF
00484:  BNZ   048C
.................... 	  setupFirstUse(); 
00486:  MOVLB  0
00488:  BRA    03EC
0048A:  MOVLB  5
.................... 	  } 
.................... } 
0048C:  MOVLB  0
0048E:  GOTO   0608 (RETURN)
....................  
.................... #include "serial.c" 
.................... /* 
....................           file: serial.c 
....................        project: SSX32 
....................    description: handles the serial uart, and isr routines 
....................  
....................    Changelog: 
....................       01/15/11 some of this code copied from another project, hence my ttls0 names 
....................  
....................  
.................... */ 
....................  
....................  
.................... #define SERIAL_STR_SIZE 255 
.................... #define SERIAL_FIFO_SIZE 255 
....................  
....................  
.................... char serFifo_ttls0[SERIAL_FIFO_SIZE]; 
.................... unsigned int8 serFifoPntr_ttls0; 
....................  
.................... char serStrBuffer_ttls0[SERIAL_STR_SIZE]; 
.................... unsigned int8 serBuffPntr_ttls0; 
....................  
.................... int1 flagSerOverFlow_ttls0; 
.................... int8 cntSerHasStrings_ttls0; 
....................  
.................... int1 serIsChrReady_ttls0(void); 
.................... int1 serIsStrReady_ttls0(void); 
.................... int8 serGetChr_ttls0(void); 
.................... void serFlushFifo_ttls0(void); 
.................... void serGetStr_ttls0(void); 
....................  
....................  
.................... // internal serial port 
.................... #int_RDA 
.................... void  isr_serRx_ttls0(void) 
.................... { 
....................    char data; 
....................  
....................    while( kbhit(ttls0) ) 
....................    { 
*
00174:  BTFSS  F9E.5
00176:  BRA    01D6
....................    data = fgetc(ttls0); 
00178:  BTFSS  F9E.5
0017A:  BRA    0178
0017C:  MOVFF  FAE,5C2
00180:  MOVLB  5
....................    if (serFifoPntr_ttls0 < SERIAL_FIFO_SIZE) 
00182:  MOVLB  4
00184:  INCFSZ x44,W
00186:  BRA    018A
00188:  BRA    01C0
....................      { 
....................      if (data == 0x0D) { cntSerHasStrings_ttls0++; } 
0018A:  MOVLB  5
0018C:  MOVF   xC2,W
0018E:  SUBLW  0D
00190:  BTFSC  FD8.2
00192:  INCF   x46,F
....................      if (data != 0x0A) 
00194:  MOVF   xC2,W
00196:  SUBLW  0A
00198:  BZ    01C2
.................... 	   { 
.................... 	   serFifo_ttls0[serFifoPntr_ttls0] = data; 
0019A:  CLRF   03
0019C:  MOVLB  4
0019E:  MOVF   x44,W
001A0:  ADDLW  45
001A2:  MOVWF  FE9
001A4:  MOVLW  03
001A6:  ADDWFC 03,W
001A8:  MOVWF  FEA
001AA:  MOVFF  5C2,FEF
....................        serFifoPntr_ttls0++; 
001AE:  INCF   x44,F
....................        serFifo_ttls0[serFifoPntr_ttls0] = 0x00; 
001B0:  CLRF   03
001B2:  MOVF   x44,W
001B4:  ADDLW  45
001B6:  MOVWF  FE9
001B8:  MOVLW  03
001BA:  ADDWFC 03,W
001BC:  MOVWF  FEA
001BE:  CLRF   FEF
001C0:  MOVLB  5
.................... 	   } 
....................      } 
....................  
....................    if (serFifoPntr_ttls0 == SERIAL_FIFO_SIZE) 
001C2:  MOVLB  4
001C4:  INCFSZ x44,W
001C6:  BRA    01D2
....................      { 
....................      flagSerOverFlow_ttls0 = TRUE; 
001C8:  MOVLB  5
001CA:  BSF    x45.0
....................      serFlushFifo_ttls0(); 
001CC:  MOVLB  0
001CE:  RCALL  0116
.................... 	 error_serOverflow(); 
001D0:  BRA    0152
....................      } 
....................    } 
001D2:  MOVLB  0
001D4:  BRA    0174
....................  
.................... } 
....................  
....................  
....................  
001D6:  BCF    F9E.5
001D8:  GOTO   0060
.................... void serFlushFifo_ttls0(void) 
.................... { 
....................    serFifoPntr_ttls0 = 0; 
*
00116:  MOVLB  4
00118:  CLRF   x44
....................    cntSerHasStrings_ttls0 = 0; 
0011A:  MOVLB  5
0011C:  CLRF   x46
....................    flagSerOverFlow_ttls0 = FALSE; 
0011E:  BCF    x45.0
....................    serStrBuffer_ttls0[0] = 0x00; 
00120:  MOVLB  4
00122:  CLRF   x45
.................... } 
00124:  MOVLB  0
00126:  RETLW  00
....................  
....................  
.................... int1 serIsChrReady_ttls0(void) 
.................... { 
....................    int1 res; 
....................    //puts("serIsChrReady()"); 
....................    res = FALSE; 
*
01ACE:  MOVLB  5
01AD0:  BCF    x69.0
....................    if (serFifoPntr_ttls0 > 0) { 
01AD2:  MOVLB  4
01AD4:  MOVF   x44,F
01AD6:  BZ    1ADC
....................      res = TRUE; 
01AD8:  MOVLB  5
01ADA:  BSF    x69.0
....................      } 
....................    return res; 
01ADC:  MOVLW  00
01ADE:  MOVLB  5
01AE0:  BTFSC  x69.0
01AE2:  MOVLW  01
01AE4:  MOVWF  01
.................... } 
01AE6:  MOVLB  0
01AE8:  GOTO   1AEE (RETURN)
....................  
.................... int1 serIsStrReady_ttls0(void) 
.................... { 
....................    int1 res; 
....................    res = FALSE; 
*
01AB6:  MOVLB  5
01AB8:  BCF    x5D.0
....................    if ( cntSerHasStrings_ttls0 > 0) { 
01ABA:  MOVF   x46,F
01ABC:  BZ    1AC0
....................      res = TRUE; 
01ABE:  BSF    x5D.0
....................      } 
....................    return res; 
01AC0:  MOVLW  00
01AC2:  BTFSC  x5D.0
01AC4:  MOVLW  01
01AC6:  MOVWF  01
.................... } 
01AC8:  MOVLB  0
01ACA:  GOTO   3914 (RETURN)
....................  
....................  
.................... int8 serGetChr_ttls0(void) 
.................... { 
....................    int8 res; 
....................    int8 i; 
....................  
....................    //disable_interrupts(INT_RDA); 
....................    //puts("serGetChr()"); 
....................    while (serIsChrReady_ttls0() == 0); // wait for a chr 
*
01AEC:  BRA    1ACE
01AEE:  MOVF   01,F
01AF0:  BZ    1AEC
....................    res = serFifo_ttls0[0];  // get first chr 
01AF2:  MOVFF  345,567
....................    if (res == 0x0D) { cntSerHasStrings_ttls0--; } 
01AF6:  MOVLB  5
01AF8:  MOVF   x67,W
01AFA:  SUBLW  0D
01AFC:  BTFSC  FD8.2
01AFE:  DECF   x46,F
....................    //puts("serGetChr() - chr received"); 
....................    //putc(res); 
....................    // rotate the fifo buffer 
....................    for (i=0; i < serFifoPntr_ttls0; i++) { 
01B00:  CLRF   x68
01B02:  MOVLB  4
01B04:  MOVF   x44,W
01B06:  MOVLB  5
01B08:  SUBWF  x68,W
01B0A:  BC    1B40
....................      serFifo_ttls0[i] = serFifo_ttls0[i+1]; 
01B0C:  CLRF   03
01B0E:  MOVF   x68,W
01B10:  ADDLW  45
01B12:  MOVWF  01
01B14:  MOVLW  03
01B16:  ADDWFC 03,F
01B18:  MOVFF  03,56A
01B1C:  MOVLW  01
01B1E:  ADDWF  x68,W
01B20:  CLRF   03
01B22:  ADDLW  45
01B24:  MOVWF  FE9
01B26:  MOVLW  03
01B28:  ADDWFC 03,W
01B2A:  MOVWF  FEA
01B2C:  MOVFF  FEF,56B
01B30:  MOVFF  56A,FEA
01B34:  MOVFF  01,FE9
01B38:  MOVFF  56B,FEF
....................      } 
01B3C:  INCF   x68,F
01B3E:  BRA    1B02
....................    serFifoPntr_ttls0--; 
01B40:  MOVLB  4
01B42:  DECF   x44,F
....................    //putc(TERM_XON); 
....................    //enable_interrupts(INT_RDA); 
....................    return res; 
01B44:  MOVLB  5
01B46:  MOVFF  567,01
.................... } 
01B4A:  MOVLB  0
01B4C:  GOTO   1B64 (RETURN)
....................  
....................  
....................  
.................... void serGetStr_ttls0(void) 
.................... { 
....................    char data; 
....................    int1 flagExit; 
....................  
....................    flagExit = 0; 
01B50:  MOVLB  5
01B52:  BCF    x66.0
....................    serBuffPntr_ttls0 = 0; 
01B54:  CLRF   x44
....................    serStrBuffer_ttls0[0] = 0x00; 
01B56:  MOVLB  4
01B58:  CLRF   x45
....................  
....................    while (flagExit == 0) 
....................      { 
01B5A:  MOVLB  5
01B5C:  BTFSC  x66.0
01B5E:  BRA    1BA4
....................      data = serGetChr_ttls0(); 
01B60:  MOVLB  0
01B62:  BRA    1AEC
01B64:  MOVFF  01,565
....................  
....................      if (data == 0x0D) { 
01B68:  MOVLB  5
01B6A:  MOVF   x65,W
01B6C:  SUBLW  0D
01B6E:  BNZ   1B72
....................        flagExit = 1; 
01B70:  BSF    x66.0
....................        } 
....................  
....................      if ( (data > 0x19) && (serBuffPntr_ttls0 < SERIAL_STR_SIZE) ) { 
01B72:  MOVF   x65,W
01B74:  SUBLW  19
01B76:  BC    1BA2
01B78:  INCFSZ x44,W
01B7A:  BRA    1B7E
01B7C:  BRA    1BA2
....................        serStrBuffer_ttls0[serBuffPntr_ttls0] = data; 
01B7E:  CLRF   03
01B80:  MOVF   x44,W
01B82:  ADDLW  45
01B84:  MOVWF  FE9
01B86:  MOVLW  04
01B88:  ADDWFC 03,W
01B8A:  MOVWF  FEA
01B8C:  MOVFF  565,FEF
....................        serBuffPntr_ttls0++; 
01B90:  INCF   x44,F
....................        serStrBuffer_ttls0[serBuffPntr_ttls0] = 0x00; 
01B92:  CLRF   03
01B94:  MOVF   x44,W
01B96:  ADDLW  45
01B98:  MOVWF  FE9
01B9A:  MOVLW  04
01B9C:  ADDWFC 03,W
01B9E:  MOVWF  FEA
01BA0:  CLRF   FEF
....................        } 
....................  
....................      } 
01BA2:  BRA    1B5C
....................  
....................    //printf("serGetStr_res:%s:\r\n",serStrBuffer); 
....................  
.................... } 
01BA4:  MOVLB  0
01BA6:  GOTO   37CA (RETURN)
....................  
....................  
....................  
.................... #include "input.c" 
.................... /* 
....................           file: input.c 
....................        project: SSX32 
....................    description: processing of the input strings 
....................  
....................    Changelog: 
.................... 	  02/25/11 added the SIN function/command !SIN 
....................       01/15/11 this file created 
....................  
....................  
.................... */ 
....................  
....................  
.................... #define PARAM_SIZE	20		// max param string size 
.................... char strParam[PARAM_SIZE]; 
....................  
.................... int8 ndxPointer; 
.................... int8 flagFinished; 
....................  
....................  
.................... void shiftParam(void) 
.................... { 
.................... 	char c; 
.................... 	int8 i; 
....................  
.................... 	#ifdef DEBUG_INPUT 
.................... 	  fprintf(ttls0,"shiftParam(%s:",strParam); 
.................... 	#endif 
.................... 	 
.................... 	i=1; 
*
01F76:  MOVLW  01
01F78:  MOVLB  5
01F7A:  MOVWF  x75
.................... 	c = strParam[i]; 
01F7C:  CLRF   03
01F7E:  MOVF   x75,W
01F80:  ADDLW  47
01F82:  MOVWF  FE9
01F84:  MOVLW  05
01F86:  ADDWFC 03,W
01F88:  MOVWF  FEA
01F8A:  MOVFF  FEF,574
.................... 	while (c != 0x00) 
.................... 	  { 
01F8E:  MOVF   x74,F
01F90:  BZ    1FBC
.................... 	  strParam[i-1] = c; 
01F92:  MOVLW  01
01F94:  SUBWF  x75,W
01F96:  CLRF   03
01F98:  ADDLW  47
01F9A:  MOVWF  FE9
01F9C:  MOVLW  05
01F9E:  ADDWFC 03,W
01FA0:  MOVWF  FEA
01FA2:  MOVFF  574,FEF
.................... 	  i++; 
01FA6:  INCF   x75,F
.................... 	  c = strParam[i]; 
01FA8:  CLRF   03
01FAA:  MOVF   x75,W
01FAC:  ADDLW  47
01FAE:  MOVWF  FE9
01FB0:  MOVLW  05
01FB2:  ADDWFC 03,W
01FB4:  MOVWF  FEA
01FB6:  MOVFF  FEF,574
.................... 	  } 
01FBA:  BRA    1F8E
.................... 	  strParam[i-1] = 0x00; 
01FBC:  MOVLW  01
01FBE:  SUBWF  x75,W
01FC0:  CLRF   03
01FC2:  ADDLW  47
01FC4:  MOVWF  FE9
01FC6:  MOVLW  05
01FC8:  ADDWFC 03,W
01FCA:  MOVWF  FEA
01FCC:  CLRF   FEF
....................  
.................... 	#ifdef DEBUG_INPUT 
.................... 	  fprintf(ttls0,"%s)\r\n",strParam); 
.................... 	#endif 
.................... 	   
.................... } 
01FCE:  MOVLB  0
01FD0:  GOTO   2D04 (RETURN)
....................  
.................... void parseSubStr(void) 
.................... { 
.................... 	int8 i; 
.................... 	char p; 
.................... 	signed int16 val; 
.................... 	float sinVal; 
.................... 	int16 sinCenter; 
.................... 	 
.................... 	#ifdef DEBUG_INPUT 
.................... 	  fprintf(ttls0,"parseSubStr(%s)\r\n",strParam); 
.................... 	#endif 
.................... 	 
.................... 	p = strParam[0]; 
*
02CFC:  MOVFF  547,566
.................... 	shiftParam();	// kill leading chr. 
02D00:  GOTO   1F76
.................... 	val = atol(strParam); 
02D04:  MOVLW  05
02D06:  MOVLB  5
02D08:  MOVWF  x75
02D0A:  MOVLW  47
02D0C:  MOVWF  x74
02D0E:  MOVLB  0
02D10:  GOTO   202A
02D14:  MOVFF  02,568
02D18:  MOVFF  01,567
.................... 	 
.................... 	#ifdef DEBUG_INPUT 
.................... 	  fprintf(ttls0,"(value=%Li)\r\n",val); 
.................... 	#endif 
.................... 	 
.................... 	switch (p) 
.................... 	  { 
02D1C:  MOVLB  5
02D1E:  MOVF   x66,W
02D20:  XORLW  23
02D22:  MOVLB  0
02D24:  BZ    2D74
02D26:  XORLW  77
02D28:  BZ    2D8C
02D2A:  XORLW  04
02D2C:  BZ    2D98
02D2E:  XORLW  19
02D30:  BTFSC  FD8.2
02D32:  BRA    310A
02D34:  XORLW  64
02D36:  BTFSC  FD8.2
02D38:  BRA    315A
02D3A:  XORLW  06
02D3C:  BTFSC  FD8.2
02D3E:  BRA    31D6
02D40:  XORLW  78
02D42:  BTFSC  FD8.2
02D44:  BRA    3252
02D46:  XORLW  10
02D48:  BTFSC  FD8.2
02D4A:  BRA    3292
02D4C:  XORLW  05
02D4E:  BTFSC  FD8.2
02D50:  BRA    32FA
02D52:  XORLW  0B
02D54:  BTFSC  FD8.2
02D56:  BRA    3362
02D58:  XORLW  02
02D5A:  BTFSC  FD8.2
02D5C:  BRA    33CA
02D5E:  XORLW  07
02D60:  BTFSC  FD8.2
02D62:  BRA    343E
02D64:  XORLW  1A
02D66:  BTFSC  FD8.2
02D68:  BRA    34B2
02D6A:  XORLW  73
02D6C:  BTFSC  FD8.2
02D6E:  BRA    353A
02D70:  GOTO   37C2
.................... 		case '#': 
.................... 			modalServo = val-1;	// since our board silkscreen is numbered 1-32, we -1 
02D74:  MOVLW  01
02D76:  MOVLB  5
02D78:  SUBWF  x67,W
02D7A:  MOVWF  00
02D7C:  MOVLW  00
02D7E:  SUBWFB x68,W
02D80:  MOVFF  00,340
02D84:  MOVLB  3
.................... 			break; 
02D86:  MOVLB  0
02D88:  GOTO   37C2
....................  
.................... 		case 'T': 
.................... 			modalTime = val; 
02D8C:  MOVFF  568,342
02D90:  MOVFF  567,341
.................... 			break; 
02D94:  GOTO   37C2
....................  
.................... 		case 'P': 
.................... 			servo[modalServo].mode = MODE_NORMAL; 
02D98:  MOVLB  5
02D9A:  CLRF   x79
02D9C:  MOVFF  340,578
02DA0:  CLRF   x7B
02DA2:  MOVLW  18
02DA4:  MOVWF  x7A
02DA6:  MOVLB  0
02DA8:  CALL   0492
02DAC:  MOVLW  20
02DAE:  MOVLB  5
02DB0:  ADDWF  01,W
02DB2:  MOVWF  FE9
02DB4:  MOVLW  00
02DB6:  ADDWFC 02,W
02DB8:  MOVWF  FEA
02DBA:  MOVLW  01
02DBC:  MOVWF  FEF
.................... 			if (flagSin == true) 
02DBE:  MOVLB  3
02DC0:  DECFSZ x44,W
02DC2:  BRA    2FDC
.................... 			  { 
.................... 			  // is !SIN mode is on, then readjust the value 
.................... 			  //fprintf(ttls0,"(value=%Li)\r\n",val); 
.................... 			  sinCenter = ( (servo[modalServo].max - servo[modalServo].min) / 2 ) + servo[modalServo].min; 
02DC4:  MOVLB  5
02DC6:  CLRF   x79
02DC8:  MOVFF  340,578
02DCC:  CLRF   x7B
02DCE:  MOVLW  18
02DD0:  MOVWF  x7A
02DD2:  MOVLB  0
02DD4:  CALL   0492
02DD8:  MOVFF  01,574
02DDC:  MOVLW  0E
02DDE:  MOVLB  5
02DE0:  ADDWF  01,W
02DE2:  MOVWF  01
02DE4:  MOVLW  00
02DE6:  ADDWFC 02,W
02DE8:  MOVWF  03
02DEA:  MOVF   01,W
02DEC:  ADDLW  20
02DEE:  MOVWF  FE9
02DF0:  MOVLW  00
02DF2:  ADDWFC 03,W
02DF4:  MOVWF  FEA
02DF6:  MOVFF  FEC,575
02DFA:  MOVF   FED,F
02DFC:  MOVFF  FEF,574
02E00:  CLRF   x79
02E02:  MOVFF  340,578
02E06:  CLRF   x7B
02E08:  MOVLW  18
02E0A:  MOVWF  x7A
02E0C:  MOVLB  0
02E0E:  CALL   0492
02E12:  MOVFF  02,577
02E16:  MOVFF  01,576
02E1A:  MOVLW  0C
02E1C:  MOVLB  5
02E1E:  ADDWF  01,W
02E20:  MOVWF  01
02E22:  MOVLW  00
02E24:  ADDWFC 02,W
02E26:  MOVWF  03
02E28:  MOVF   01,W
02E2A:  ADDLW  20
02E2C:  MOVWF  FE9
02E2E:  MOVLW  00
02E30:  ADDWFC 03,W
02E32:  MOVWF  FEA
02E34:  MOVFF  FEC,03
02E38:  MOVF   FED,F
02E3A:  MOVF   FEF,W
02E3C:  SUBWF  x74,F
02E3E:  MOVF   03,W
02E40:  SUBWFB x75,F
02E42:  BCF    FD8.0
02E44:  RRCF   x75,F
02E46:  RRCF   x74,F
02E48:  CLRF   x79
02E4A:  MOVFF  340,578
02E4E:  CLRF   x7B
02E50:  MOVLW  18
02E52:  MOVWF  x7A
02E54:  MOVLB  0
02E56:  CALL   0492
02E5A:  MOVFF  01,576
02E5E:  MOVLW  0C
02E60:  MOVLB  5
02E62:  ADDWF  01,W
02E64:  MOVWF  01
02E66:  MOVLW  00
02E68:  ADDWFC 02,W
02E6A:  MOVWF  03
02E6C:  MOVF   01,W
02E6E:  ADDLW  20
02E70:  MOVWF  FE9
02E72:  MOVLW  00
02E74:  ADDWFC 03,W
02E76:  MOVWF  FEA
02E78:  MOVFF  FEC,03
02E7C:  MOVF   FED,F
02E7E:  MOVF   FEF,W
02E80:  ADDWF  x74,W
02E82:  MOVWF  x6D
02E84:  MOVF   03,W
02E86:  ADDWFC x75,W
02E88:  MOVWF  x6E
.................... 			  //fprintf(ttls0,"sinCenter: %Li\r\n",sinCenter); 
.................... 			  sinVal = sin(val/57.2957795); 
02E8A:  MOVFF  568,575
02E8E:  MOVFF  567,574
02E92:  MOVFF  568,577
02E96:  MOVFF  567,576
02E9A:  MOVLB  0
02E9C:  GOTO   221C
02EA0:  MOVFF  03,579
02EA4:  MOVFF  02,578
02EA8:  MOVFF  01,577
02EAC:  MOVFF  00,576
02EB0:  MOVLW  E1
02EB2:  MOVLB  5
02EB4:  MOVWF  x7D
02EB6:  MOVLW  2E
02EB8:  MOVWF  x7C
02EBA:  MOVLW  65
02EBC:  MOVWF  x7B
02EBE:  MOVLW  84
02EC0:  MOVWF  x7A
02EC2:  MOVLB  0
02EC4:  GOTO   226E
02EC8:  MOVFF  00,574
02ECC:  MOVFF  01,575
02ED0:  MOVFF  02,576
02ED4:  MOVFF  03,577
02ED8:  MOVFF  03,57B
02EDC:  MOVFF  02,57A
02EE0:  MOVFF  01,579
02EE4:  MOVFF  00,578
02EE8:  BRA    2BBC
02EEA:  MOVFF  03,56C
02EEE:  MOVFF  02,56B
02EF2:  MOVFF  01,56A
02EF6:  MOVFF  00,569
.................... 			  //fprintf(ttls0,"sinVal: %f\r\n",sinVal); 
.................... 			  val = (sinVal * (servo[modalServo].max - sinCenter) ) + sinCenter; 
02EFA:  MOVLB  5
02EFC:  CLRF   x79
02EFE:  MOVFF  340,578
02F02:  CLRF   x7B
02F04:  MOVLW  18
02F06:  MOVWF  x7A
02F08:  MOVLB  0
02F0A:  CALL   0492
02F0E:  MOVFF  01,574
02F12:  MOVLW  0E
02F14:  MOVLB  5
02F16:  ADDWF  01,W
02F18:  MOVWF  01
02F1A:  MOVLW  00
02F1C:  ADDWFC 02,W
02F1E:  MOVWF  03
02F20:  MOVF   01,W
02F22:  ADDLW  20
02F24:  MOVWF  FE9
02F26:  MOVLW  00
02F28:  ADDWFC 03,W
02F2A:  MOVWF  FEA
02F2C:  MOVFF  FEC,575
02F30:  MOVF   FED,F
02F32:  MOVFF  FEF,574
02F36:  MOVF   x6D,W
02F38:  SUBWF  x74,W
02F3A:  MOVWF  00
02F3C:  MOVF   x6E,W
02F3E:  SUBWFB x75,W
02F40:  MOVWF  03
02F42:  MOVFF  00,5B2
02F46:  MOVWF  xB3
02F48:  MOVLB  0
02F4A:  RCALL  27F4
02F4C:  MOVFF  56C,5B5
02F50:  MOVFF  56B,5B4
02F54:  MOVFF  56A,5B3
02F58:  MOVFF  569,5B2
02F5C:  MOVFF  03,5B9
02F60:  MOVFF  02,5B8
02F64:  MOVFF  01,5B7
02F68:  MOVFF  00,5B6
02F6C:  CALL   26C2
02F70:  MOVFF  00,574
02F74:  MOVFF  01,575
02F78:  MOVFF  02,576
02F7C:  MOVFF  03,577
02F80:  MOVFF  56E,5B3
02F84:  MOVFF  56D,5B2
02F88:  RCALL  27F4
02F8A:  MOVFF  FEA,579
02F8E:  MOVFF  FE9,578
02F92:  BCF    FD8.1
02F94:  MOVFF  577,5B5
02F98:  MOVFF  576,5B4
02F9C:  MOVFF  575,5B3
02FA0:  MOVFF  574,5B2
02FA4:  MOVFF  03,5B9
02FA8:  MOVFF  02,5B8
02FAC:  MOVFF  01,5B7
02FB0:  MOVFF  00,5B6
02FB4:  CALL   23CE
02FB8:  MOVFF  579,FEA
02FBC:  MOVFF  578,FE9
02FC0:  MOVFF  03,5B1
02FC4:  MOVFF  02,5B0
02FC8:  MOVFF  01,5AF
02FCC:  MOVFF  00,5AE
02FD0:  CALL   27B8
02FD4:  MOVFF  02,568
02FD8:  MOVFF  01,567
.................... 			  } 
.................... 			//fprintf(ttls0,"(value=%Li)\r\n",val); 
.................... 			servo[modalServo].pwDestination = val; 
02FDC:  MOVLB  5
02FDE:  CLRF   x79
02FE0:  MOVFF  340,578
02FE4:  CLRF   x7B
02FE6:  MOVLW  18
02FE8:  MOVWF  x7A
02FEA:  MOVLB  0
02FEC:  CALL   0492
02FF0:  MOVFF  01,574
02FF4:  MOVLW  03
02FF6:  MOVLB  5
02FF8:  ADDWF  01,W
02FFA:  MOVWF  01
02FFC:  MOVLW  00
02FFE:  ADDWFC 02,W
03000:  MOVWF  03
03002:  MOVF   01,W
03004:  ADDLW  20
03006:  MOVWF  FE9
03008:  MOVLW  00
0300A:  ADDWFC 03,W
0300C:  MOVWF  FEA
0300E:  MOVFF  568,FEC
03012:  MOVF   FED,F
03014:  MOVFF  567,FEF
.................... 			boundsCheck(modalServo); 
03018:  MOVFF  340,574
0301C:  MOVLB  0
0301E:  CALL   09F6
.................... 			if ( modalTime !=0 ) 
03022:  MOVLB  3
03024:  MOVF   x41,F
03026:  BNZ   302C
03028:  MOVF   x42,F
0302A:  BZ    3106
.................... 			  { 
.................... 			  // set a step size based on modal time 
.................... 			  servo[modalServo].step = retStepOverTime(servo[modalServo].pwCurrent,servo[modalServo].pwDestination,modalTime);			   
0302C:  MOVLB  5
0302E:  CLRF   x79
03030:  MOVFF  340,578
03034:  CLRF   x7B
03036:  MOVLW  18
03038:  MOVWF  x7A
0303A:  MOVLB  0
0303C:  CALL   0492
03040:  MOVFF  01,574
03044:  MOVLW  05
03046:  MOVLB  5
03048:  ADDWF  01,W
0304A:  MOVWF  01
0304C:  MOVLW  00
0304E:  ADDWFC 02,W
03050:  MOVWF  03
03052:  MOVF   01,W
03054:  ADDLW  20
03056:  MOVWF  01
03058:  MOVLW  00
0305A:  ADDWFC 03,F
0305C:  MOVFF  01,574
03060:  MOVFF  03,575
03064:  CLRF   x79
03066:  MOVFF  340,578
0306A:  CLRF   x7B
0306C:  MOVLW  18
0306E:  MOVWF  x7A
03070:  MOVLB  0
03072:  CALL   0492
03076:  MOVFF  01,576
0307A:  MOVLW  01
0307C:  MOVLB  5
0307E:  ADDWF  01,W
03080:  MOVWF  01
03082:  MOVLW  00
03084:  ADDWFC 02,W
03086:  MOVWF  03
03088:  MOVF   01,W
0308A:  ADDLW  20
0308C:  MOVWF  FE9
0308E:  MOVLW  00
03090:  ADDWFC 03,W
03092:  MOVWF  FEA
03094:  MOVFF  FEC,577
03098:  MOVF   FED,F
0309A:  MOVFF  FEF,576
0309E:  CLRF   x79
030A0:  MOVFF  340,578
030A4:  CLRF   x7B
030A6:  MOVLW  18
030A8:  MOVWF  x7A
030AA:  MOVLB  0
030AC:  CALL   0492
030B0:  MOVFF  01,578
030B4:  MOVLW  03
030B6:  MOVLB  5
030B8:  ADDWF  01,W
030BA:  MOVWF  01
030BC:  MOVLW  00
030BE:  ADDWFC 02,W
030C0:  MOVWF  03
030C2:  MOVF   01,W
030C4:  ADDLW  20
030C6:  MOVWF  FE9
030C8:  MOVLW  00
030CA:  ADDWFC 03,W
030CC:  MOVWF  FEA
030CE:  MOVFF  FEC,579
030D2:  MOVF   FED,F
030D4:  MOVFF  FEF,578
030D8:  MOVFF  577,57B
030DC:  MOVFF  576,57A
030E0:  MOVFF  579,57D
030E4:  MOVFF  578,57C
030E8:  MOVFF  342,57F
030EC:  MOVFF  341,57E
030F0:  MOVLB  0
030F2:  BRA    2C9C
030F4:  MOVFF  575,FEA
030F8:  MOVFF  574,FE9
030FC:  MOVFF  02,FEC
03100:  MOVF   FED,F
03102:  MOVFF  01,FEF
.................... 			  } 
.................... 			break; 
03106:  MOVLB  0
03108:  BRA    37C2
....................  
.................... 		case 'I': 
.................... 			servo[modalServo].pwDestination += val; 
0310A:  MOVLB  5
0310C:  CLRF   x79
0310E:  MOVFF  340,578
03112:  CLRF   x7B
03114:  MOVLW  18
03116:  MOVWF  x7A
03118:  MOVLB  0
0311A:  CALL   0492
0311E:  MOVFF  01,574
03122:  MOVLW  03
03124:  MOVLB  5
03126:  ADDWF  01,W
03128:  MOVWF  01
0312A:  MOVLW  00
0312C:  ADDWFC 02,W
0312E:  MOVWF  03
03130:  MOVF   01,W
03132:  ADDLW  20
03134:  MOVWF  FE9
03136:  MOVLW  00
03138:  ADDWFC 03,W
0313A:  MOVWF  FEA
0313C:  MOVF   x67,W
0313E:  ADDWF  FEF,W
03140:  MOVWF  01
03142:  MOVF   x68,W
03144:  ADDWFC FEC,W
03146:  MOVF   FED,F
03148:  MOVFF  01,FEF
0314C:  MOVWF  FEC
.................... 			boundsCheck(modalServo); 
0314E:  MOVFF  340,574
03152:  MOVLB  0
03154:  CALL   09F6
.................... 			break; 
03158:  BRA    37C2
....................  
.................... 		case '-': 
.................... 			servo[modalServo].min = val; 
0315A:  MOVLB  5
0315C:  CLRF   x79
0315E:  MOVFF  340,578
03162:  CLRF   x7B
03164:  MOVLW  18
03166:  MOVWF  x7A
03168:  MOVLB  0
0316A:  CALL   0492
0316E:  MOVFF  01,574
03172:  MOVLW  0C
03174:  MOVLB  5
03176:  ADDWF  01,W
03178:  MOVWF  01
0317A:  MOVLW  00
0317C:  ADDWFC 02,W
0317E:  MOVWF  03
03180:  MOVF   01,W
03182:  ADDLW  20
03184:  MOVWF  FE9
03186:  MOVLW  00
03188:  ADDWFC 03,W
0318A:  MOVWF  FEA
0318C:  MOVFF  568,FEC
03190:  MOVF   FED,F
03192:  MOVFF  567,FEF
.................... 			servo[modalServo].writeMin = true; 
03196:  CLRF   x79
03198:  MOVFF  340,578
0319C:  CLRF   x7B
0319E:  MOVLW  18
031A0:  MOVWF  x7A
031A2:  MOVLB  0
031A4:  CALL   0492
031A8:  MOVFF  01,574
031AC:  MOVLW  12
031AE:  MOVLB  5
031B0:  ADDWF  01,W
031B2:  MOVWF  01
031B4:  MOVLW  00
031B6:  ADDWFC 02,W
031B8:  MOVWF  03
031BA:  MOVF   01,W
031BC:  ADDLW  20
031BE:  MOVWF  FE9
031C0:  MOVLW  00
031C2:  ADDWFC 03,W
031C4:  MOVWF  FEA
031C6:  MOVLW  01
031C8:  MOVWF  FEF
.................... 			boundsCheck(modalServo); 
031CA:  MOVFF  340,574
031CE:  MOVLB  0
031D0:  CALL   09F6
.................... 			break; 
031D4:  BRA    37C2
....................  
.................... 		case '+': 
.................... 			servo[modalServo].max = val; 
031D6:  MOVLB  5
031D8:  CLRF   x79
031DA:  MOVFF  340,578
031DE:  CLRF   x7B
031E0:  MOVLW  18
031E2:  MOVWF  x7A
031E4:  MOVLB  0
031E6:  CALL   0492
031EA:  MOVFF  01,574
031EE:  MOVLW  0E
031F0:  MOVLB  5
031F2:  ADDWF  01,W
031F4:  MOVWF  01
031F6:  MOVLW  00
031F8:  ADDWFC 02,W
031FA:  MOVWF  03
031FC:  MOVF   01,W
031FE:  ADDLW  20
03200:  MOVWF  FE9
03202:  MOVLW  00
03204:  ADDWFC 03,W
03206:  MOVWF  FEA
03208:  MOVFF  568,FEC
0320C:  MOVF   FED,F
0320E:  MOVFF  567,FEF
.................... 			servo[modalServo].writeMax = true; 
03212:  CLRF   x79
03214:  MOVFF  340,578
03218:  CLRF   x7B
0321A:  MOVLW  18
0321C:  MOVWF  x7A
0321E:  MOVLB  0
03220:  CALL   0492
03224:  MOVFF  01,574
03228:  MOVLW  13
0322A:  MOVLB  5
0322C:  ADDWF  01,W
0322E:  MOVWF  01
03230:  MOVLW  00
03232:  ADDWFC 02,W
03234:  MOVWF  03
03236:  MOVF   01,W
03238:  ADDLW  20
0323A:  MOVWF  FE9
0323C:  MOVLW  00
0323E:  ADDWFC 03,W
03240:  MOVWF  FEA
03242:  MOVLW  01
03244:  MOVWF  FEF
.................... 			boundsCheck(modalServo); 
03246:  MOVFF  340,574
0324A:  MOVLB  0
0324C:  CALL   09F6
.................... 			break; 
03250:  BRA    37C2
....................  
.................... 		case 'S': 
.................... 			servo[modalServo].step = val; 
03252:  MOVLB  5
03254:  CLRF   x79
03256:  MOVFF  340,578
0325A:  CLRF   x7B
0325C:  MOVLW  18
0325E:  MOVWF  x7A
03260:  MOVLB  0
03262:  CALL   0492
03266:  MOVFF  01,574
0326A:  MOVLW  05
0326C:  MOVLB  5
0326E:  ADDWF  01,W
03270:  MOVWF  01
03272:  MOVLW  00
03274:  ADDWFC 02,W
03276:  MOVWF  03
03278:  MOVF   01,W
0327A:  ADDLW  20
0327C:  MOVWF  FE9
0327E:  MOVLW  00
03280:  ADDWFC 03,W
03282:  MOVWF  FEA
03284:  MOVFF  568,FEC
03288:  MOVF   FED,F
0328A:  MOVFF  567,FEF
.................... 			break; 
0328E:  MOVLB  0
03290:  BRA    37C2
....................  
.................... 		case 'C': 
.................... 			servo[modalServo].mode = MODE_COPY; 
03292:  MOVLB  5
03294:  CLRF   x79
03296:  MOVFF  340,578
0329A:  CLRF   x7B
0329C:  MOVLW  18
0329E:  MOVWF  x7A
032A0:  MOVLB  0
032A2:  CALL   0492
032A6:  MOVLW  20
032A8:  MOVLB  5
032AA:  ADDWF  01,W
032AC:  MOVWF  FE9
032AE:  MOVLW  00
032B0:  ADDWFC 02,W
032B2:  MOVWF  FEA
032B4:  MOVLW  02
032B6:  MOVWF  FEF
.................... 			servo[modalServo].master = val-1; 
032B8:  CLRF   x79
032BA:  MOVFF  340,578
032BE:  CLRF   x7B
032C0:  MOVLW  18
032C2:  MOVWF  x7A
032C4:  MOVLB  0
032C6:  CALL   0492
032CA:  MOVFF  01,574
032CE:  MOVLW  14
032D0:  MOVLB  5
032D2:  ADDWF  01,W
032D4:  MOVWF  01
032D6:  MOVLW  00
032D8:  ADDWFC 02,W
032DA:  MOVWF  03
032DC:  MOVF   01,W
032DE:  ADDLW  20
032E0:  MOVWF  FE9
032E2:  MOVLW  00
032E4:  ADDWFC 03,W
032E6:  MOVWF  FEA
032E8:  MOVLW  01
032EA:  SUBWF  x67,W
032EC:  MOVWF  00
032EE:  MOVLW  00
032F0:  SUBWFB x68,W
032F2:  MOVFF  00,FEF
.................... 			break; 
032F6:  MOVLB  0
032F8:  BRA    37C2
....................  
.................... 		case 'F': 
.................... 			servo[modalServo].mode = MODE_FOLLOW; 
032FA:  MOVLB  5
032FC:  CLRF   x79
032FE:  MOVFF  340,578
03302:  CLRF   x7B
03304:  MOVLW  18
03306:  MOVWF  x7A
03308:  MOVLB  0
0330A:  CALL   0492
0330E:  MOVLW  20
03310:  MOVLB  5
03312:  ADDWF  01,W
03314:  MOVWF  FE9
03316:  MOVLW  00
03318:  ADDWFC 02,W
0331A:  MOVWF  FEA
0331C:  MOVLW  04
0331E:  MOVWF  FEF
.................... 			servo[modalServo].master = val-1; 
03320:  CLRF   x79
03322:  MOVFF  340,578
03326:  CLRF   x7B
03328:  MOVLW  18
0332A:  MOVWF  x7A
0332C:  MOVLB  0
0332E:  CALL   0492
03332:  MOVFF  01,574
03336:  MOVLW  14
03338:  MOVLB  5
0333A:  ADDWF  01,W
0333C:  MOVWF  01
0333E:  MOVLW  00
03340:  ADDWFC 02,W
03342:  MOVWF  03
03344:  MOVF   01,W
03346:  ADDLW  20
03348:  MOVWF  FE9
0334A:  MOVLW  00
0334C:  ADDWFC 03,W
0334E:  MOVWF  FEA
03350:  MOVLW  01
03352:  SUBWF  x67,W
03354:  MOVWF  00
03356:  MOVLW  00
03358:  SUBWFB x68,W
0335A:  MOVFF  00,FEF
.................... 			break; 
0335E:  MOVLB  0
03360:  BRA    37C2
....................  
.................... 		case 'M': 
.................... 			servo[modalServo].mode = MODE_MIRROR; 
03362:  MOVLB  5
03364:  CLRF   x79
03366:  MOVFF  340,578
0336A:  CLRF   x7B
0336C:  MOVLW  18
0336E:  MOVWF  x7A
03370:  MOVLB  0
03372:  CALL   0492
03376:  MOVLW  20
03378:  MOVLB  5
0337A:  ADDWF  01,W
0337C:  MOVWF  FE9
0337E:  MOVLW  00
03380:  ADDWFC 02,W
03382:  MOVWF  FEA
03384:  MOVLW  03
03386:  MOVWF  FEF
.................... 			servo[modalServo].master = val-1; 
03388:  CLRF   x79
0338A:  MOVFF  340,578
0338E:  CLRF   x7B
03390:  MOVLW  18
03392:  MOVWF  x7A
03394:  MOVLB  0
03396:  CALL   0492
0339A:  MOVFF  01,574
0339E:  MOVLW  14
033A0:  MOVLB  5
033A2:  ADDWF  01,W
033A4:  MOVWF  01
033A6:  MOVLW  00
033A8:  ADDWFC 02,W
033AA:  MOVWF  03
033AC:  MOVF   01,W
033AE:  ADDLW  20
033B0:  MOVWF  FE9
033B2:  MOVLW  00
033B4:  ADDWFC 03,W
033B6:  MOVWF  FEA
033B8:  MOVLW  01
033BA:  SUBWF  x67,W
033BC:  MOVWF  00
033BE:  MOVLW  00
033C0:  SUBWFB x68,W
033C2:  MOVFF  00,FEF
.................... 			break; 
033C6:  MOVLB  0
033C8:  BRA    37C2
....................  
.................... 		case 'O': 
.................... 			servo[modalServo].offset = val; 
033CA:  MOVLB  5
033CC:  CLRF   x79
033CE:  MOVFF  340,578
033D2:  CLRF   x7B
033D4:  MOVLW  18
033D6:  MOVWF  x7A
033D8:  MOVLB  0
033DA:  CALL   0492
033DE:  MOVFF  01,574
033E2:  MOVLW  08
033E4:  MOVLB  5
033E6:  ADDWF  01,W
033E8:  MOVWF  01
033EA:  MOVLW  00
033EC:  ADDWFC 02,W
033EE:  MOVWF  03
033F0:  MOVF   01,W
033F2:  ADDLW  20
033F4:  MOVWF  FE9
033F6:  MOVLW  00
033F8:  ADDWFC 03,W
033FA:  MOVWF  FEA
033FC:  MOVFF  568,FEC
03400:  MOVF   FED,F
03402:  MOVFF  567,FEF
.................... 			servo[modalServo].writeOffset = true; 
03406:  CLRF   x79
03408:  MOVFF  340,578
0340C:  CLRF   x7B
0340E:  MOVLW  18
03410:  MOVWF  x7A
03412:  MOVLB  0
03414:  CALL   0492
03418:  MOVFF  01,574
0341C:  MOVLW  10
0341E:  MOVLB  5
03420:  ADDWF  01,W
03422:  MOVWF  01
03424:  MOVLW  00
03426:  ADDWFC 02,W
03428:  MOVWF  03
0342A:  MOVF   01,W
0342C:  ADDLW  20
0342E:  MOVWF  FE9
03430:  MOVLW  00
03432:  ADDWFC 03,W
03434:  MOVWF  FEA
03436:  MOVLW  01
03438:  MOVWF  FEF
.................... 			break; 
0343A:  MOVLB  0
0343C:  BRA    37C2
....................  
.................... 		case 'H': 
.................... 			servo[modalServo].home = val; 
0343E:  MOVLB  5
03440:  CLRF   x79
03442:  MOVFF  340,578
03446:  CLRF   x7B
03448:  MOVLW  18
0344A:  MOVWF  x7A
0344C:  MOVLB  0
0344E:  CALL   0492
03452:  MOVFF  01,574
03456:  MOVLW  0A
03458:  MOVLB  5
0345A:  ADDWF  01,W
0345C:  MOVWF  01
0345E:  MOVLW  00
03460:  ADDWFC 02,W
03462:  MOVWF  03
03464:  MOVF   01,W
03466:  ADDLW  20
03468:  MOVWF  FE9
0346A:  MOVLW  00
0346C:  ADDWFC 03,W
0346E:  MOVWF  FEA
03470:  MOVFF  568,FEC
03474:  MOVF   FED,F
03476:  MOVFF  567,FEF
.................... 			servo[modalServo].writeHome = true; 
0347A:  CLRF   x79
0347C:  MOVFF  340,578
03480:  CLRF   x7B
03482:  MOVLW  18
03484:  MOVWF  x7A
03486:  MOVLB  0
03488:  CALL   0492
0348C:  MOVFF  01,574
03490:  MOVLW  11
03492:  MOVLB  5
03494:  ADDWF  01,W
03496:  MOVWF  01
03498:  MOVLW  00
0349A:  ADDWFC 02,W
0349C:  MOVWF  03
0349E:  MOVF   01,W
034A0:  ADDLW  20
034A2:  MOVWF  FE9
034A4:  MOVLW  00
034A6:  ADDWFC 03,W
034A8:  MOVWF  FEA
034AA:  MOVLW  01
034AC:  MOVWF  FEF
.................... 			break; 
034AE:  MOVLB  0
034B0:  BRA    37C2
....................  
.................... 		case 'R': 
.................... 			servo[modalServo].pwDestination = servo[modalServo].home; 
034B2:  MOVLB  5
034B4:  CLRF   x79
034B6:  MOVFF  340,578
034BA:  CLRF   x7B
034BC:  MOVLW  18
034BE:  MOVWF  x7A
034C0:  MOVLB  0
034C2:  CALL   0492
034C6:  MOVFF  01,574
034CA:  MOVLW  03
034CC:  MOVLB  5
034CE:  ADDWF  01,W
034D0:  MOVWF  01
034D2:  MOVLW  00
034D4:  ADDWFC 02,W
034D6:  MOVWF  03
034D8:  MOVF   01,W
034DA:  ADDLW  20
034DC:  MOVWF  01
034DE:  MOVLW  00
034E0:  ADDWFC 03,F
034E2:  MOVFF  01,574
034E6:  MOVFF  03,575
034EA:  CLRF   x79
034EC:  MOVFF  340,578
034F0:  CLRF   x7B
034F2:  MOVLW  18
034F4:  MOVWF  x7A
034F6:  MOVLB  0
034F8:  CALL   0492
034FC:  MOVFF  01,576
03500:  MOVLW  0A
03502:  MOVLB  5
03504:  ADDWF  01,W
03506:  MOVWF  01
03508:  MOVLW  00
0350A:  ADDWFC 02,W
0350C:  MOVWF  03
0350E:  MOVF   01,W
03510:  ADDLW  20
03512:  MOVWF  FE9
03514:  MOVLW  00
03516:  ADDWFC 03,W
03518:  MOVWF  FEA
0351A:  MOVFF  FEC,03
0351E:  MOVF   FED,F
03520:  MOVFF  FEF,576
03524:  MOVFF  575,FEA
03528:  MOVFF  574,FE9
0352C:  MOVFF  03,FEC
03530:  MOVF   FED,F
03532:  MOVFF  576,FEF
.................... 			break; 
03536:  MOVLB  0
03538:  BRA    37C2
....................  
.................... 		case '!': 
.................... 			if ( strcmp(strParam, "DON") == CMP_EQ ) 
0353A:  MOVLW  44
0353C:  MOVLB  5
0353E:  MOVWF  x6F
03540:  MOVLW  4F
03542:  MOVWF  x70
03544:  MOVLW  4E
03546:  MOVWF  x71
03548:  CLRF   x72
0354A:  MOVLW  05
0354C:  MOVWF  x77
0354E:  MOVLW  47
03550:  MOVWF  x76
03552:  MOVLW  05
03554:  MOVWF  x79
03556:  MOVLW  6F
03558:  MOVWF  x78
0355A:  MOVLB  0
0355C:  CALL   1C14
03560:  MOVF   01,F
03562:  BNZ   359A
.................... 			  { 
.................... 			  servo[modalServo].decel = true; 
03564:  MOVLB  5
03566:  CLRF   x79
03568:  MOVFF  340,578
0356C:  CLRF   x7B
0356E:  MOVLW  18
03570:  MOVWF  x7A
03572:  MOVLB  0
03574:  CALL   0492
03578:  MOVFF  01,574
0357C:  MOVLW  07
0357E:  MOVLB  5
03580:  ADDWF  01,W
03582:  MOVWF  01
03584:  MOVLW  00
03586:  ADDWFC 02,W
03588:  MOVWF  03
0358A:  MOVF   01,W
0358C:  ADDLW  20
0358E:  MOVWF  FE9
03590:  MOVLW  00
03592:  ADDWFC 03,W
03594:  MOVWF  FEA
03596:  MOVLW  01
03598:  MOVWF  FEF
.................... 			  } 
.................... 			if ( strcmp(strParam, "ON") == CMP_EQ ) 
0359A:  MOVLW  4F
0359C:  MOVLB  5
0359E:  MOVWF  x6F
035A0:  MOVLW  4E
035A2:  MOVWF  x70
035A4:  CLRF   x71
035A6:  MOVLW  05
035A8:  MOVWF  x77
035AA:  MOVLW  47
035AC:  MOVWF  x76
035AE:  MOVLW  05
035B0:  MOVWF  x79
035B2:  MOVLW  6F
035B4:  MOVWF  x78
035B6:  MOVLB  0
035B8:  CALL   1C14
035BC:  MOVF   01,F
035BE:  BNZ   35C4
.................... 			  { 
.................... 			  flagAllOff = false; 
035C0:  MOVLB  3
035C2:  CLRF   x43
.................... 			  } 
.................... 			if ( strcmp(strParam, "OFF") == CMP_EQ ) 
035C4:  MOVLW  4F
035C6:  MOVLB  5
035C8:  MOVWF  x6F
035CA:  MOVLW  46
035CC:  MOVWF  x70
035CE:  MOVWF  x71
035D0:  CLRF   x72
035D2:  MOVLW  05
035D4:  MOVWF  x77
035D6:  MOVLW  47
035D8:  MOVWF  x76
035DA:  MOVLW  05
035DC:  MOVWF  x79
035DE:  MOVLW  6F
035E0:  MOVWF  x78
035E2:  MOVLB  0
035E4:  CALL   1C14
035E8:  MOVF   01,F
035EA:  BNZ   3622
.................... 			  { 
.................... 			  flagAllOff = true; 
035EC:  MOVLW  01
035EE:  MOVLB  3
035F0:  MOVWF  x43
.................... 			  mServoLoop 
035F2:  MOVLB  5
035F4:  CLRF   x65
035F6:  MOVF   x65,W
035F8:  SUBLW  1F
035FA:  BNC   3622
.................... 			    { 
.................... 			    servo[modalServo].mode = MODE_OFF; 
035FC:  CLRF   x79
035FE:  MOVFF  340,578
03602:  CLRF   x7B
03604:  MOVLW  18
03606:  MOVWF  x7A
03608:  MOVLB  0
0360A:  CALL   0492
0360E:  MOVLW  20
03610:  MOVLB  5
03612:  ADDWF  01,W
03614:  MOVWF  FE9
03616:  MOVLW  00
03618:  ADDWFC 02,W
0361A:  MOVWF  FEA
0361C:  CLRF   FEF
.................... 			    } 
0361E:  INCF   x65,F
03620:  BRA    35F6
.................... 			  } 
.................... 			if ( strcmp(strParam, "HOME") == CMP_EQ ) 
03622:  MOVLW  48
03624:  MOVLB  5
03626:  MOVWF  x6F
03628:  MOVLW  4F
0362A:  MOVWF  x70
0362C:  MOVLW  4D
0362E:  MOVWF  x71
03630:  MOVLW  45
03632:  MOVWF  x72
03634:  CLRF   x73
03636:  MOVLW  05
03638:  MOVWF  x77
0363A:  MOVLW  47
0363C:  MOVWF  x76
0363E:  MOVLW  05
03640:  MOVWF  x79
03642:  MOVLW  6F
03644:  MOVWF  x78
03646:  MOVLB  0
03648:  CALL   1C14
0364C:  MOVF   01,F
0364E:  BTFSS  FD8.2
03650:  BRA    378E
.................... 			  { 
.................... 			  flagAllOff = false; 
03652:  MOVLB  3
03654:  CLRF   x43
.................... 			  mServoLoop 
03656:  MOVLB  5
03658:  CLRF   x65
0365A:  MOVF   x65,W
0365C:  SUBLW  1F
0365E:  BTFSS  FD8.0
03660:  BRA    378E
.................... 			    { 
.................... 			    servo[modalServo].mode = MODE_NORMAL; 
03662:  CLRF   x79
03664:  MOVFF  340,578
03668:  CLRF   x7B
0366A:  MOVLW  18
0366C:  MOVWF  x7A
0366E:  MOVLB  0
03670:  CALL   0492
03674:  MOVLW  20
03676:  MOVLB  5
03678:  ADDWF  01,W
0367A:  MOVWF  FE9
0367C:  MOVLW  00
0367E:  ADDWFC 02,W
03680:  MOVWF  FEA
03682:  MOVLW  01
03684:  MOVWF  FEF
.................... 				servo[modalServo].pwCurrent = servo[modalServo].home; 
03686:  CLRF   x79
03688:  MOVFF  340,578
0368C:  CLRF   x7B
0368E:  MOVLW  18
03690:  MOVWF  x7A
03692:  MOVLB  0
03694:  CALL   0492
03698:  MOVFF  01,574
0369C:  MOVLW  01
0369E:  MOVLB  5
036A0:  ADDWF  01,W
036A2:  MOVWF  01
036A4:  MOVLW  00
036A6:  ADDWFC 02,W
036A8:  MOVWF  03
036AA:  MOVF   01,W
036AC:  ADDLW  20
036AE:  MOVWF  01
036B0:  MOVLW  00
036B2:  ADDWFC 03,F
036B4:  MOVFF  01,574
036B8:  MOVFF  03,575
036BC:  CLRF   x79
036BE:  MOVFF  340,578
036C2:  CLRF   x7B
036C4:  MOVLW  18
036C6:  MOVWF  x7A
036C8:  MOVLB  0
036CA:  CALL   0492
036CE:  MOVFF  01,576
036D2:  MOVLW  0A
036D4:  MOVLB  5
036D6:  ADDWF  01,W
036D8:  MOVWF  01
036DA:  MOVLW  00
036DC:  ADDWFC 02,W
036DE:  MOVWF  03
036E0:  MOVF   01,W
036E2:  ADDLW  20
036E4:  MOVWF  FE9
036E6:  MOVLW  00
036E8:  ADDWFC 03,W
036EA:  MOVWF  FEA
036EC:  MOVFF  FEC,03
036F0:  MOVF   FED,F
036F2:  MOVFF  FEF,576
036F6:  MOVFF  575,FEA
036FA:  MOVFF  574,FE9
036FE:  MOVFF  03,FEC
03702:  MOVF   FED,F
03704:  MOVFF  576,FEF
.................... 				servo[modalServo].pwDestination = servo[modalServo].home; 
03708:  CLRF   x79
0370A:  MOVFF  340,578
0370E:  CLRF   x7B
03710:  MOVLW  18
03712:  MOVWF  x7A
03714:  MOVLB  0
03716:  CALL   0492
0371A:  MOVFF  01,574
0371E:  MOVLW  03
03720:  MOVLB  5
03722:  ADDWF  01,W
03724:  MOVWF  01
03726:  MOVLW  00
03728:  ADDWFC 02,W
0372A:  MOVWF  03
0372C:  MOVF   01,W
0372E:  ADDLW  20
03730:  MOVWF  01
03732:  MOVLW  00
03734:  ADDWFC 03,F
03736:  MOVFF  01,574
0373A:  MOVFF  03,575
0373E:  CLRF   x79
03740:  MOVFF  340,578
03744:  CLRF   x7B
03746:  MOVLW  18
03748:  MOVWF  x7A
0374A:  MOVLB  0
0374C:  CALL   0492
03750:  MOVFF  01,576
03754:  MOVLW  0A
03756:  MOVLB  5
03758:  ADDWF  01,W
0375A:  MOVWF  01
0375C:  MOVLW  00
0375E:  ADDWFC 02,W
03760:  MOVWF  03
03762:  MOVF   01,W
03764:  ADDLW  20
03766:  MOVWF  FE9
03768:  MOVLW  00
0376A:  ADDWFC 03,W
0376C:  MOVWF  FEA
0376E:  MOVFF  FEC,03
03772:  MOVF   FED,F
03774:  MOVFF  FEF,576
03778:  MOVFF  575,FEA
0377C:  MOVFF  574,FE9
03780:  MOVFF  03,FEC
03784:  MOVF   FED,F
03786:  MOVFF  576,FEF
.................... 			    } 
0378A:  INCF   x65,F
0378C:  BRA    365A
.................... 			  } 
.................... 			if ( strcmp(strParam, "SIN") == CMP_EQ ) 
0378E:  MOVLW  53
03790:  MOVLB  5
03792:  MOVWF  x6F
03794:  MOVLW  49
03796:  MOVWF  x70
03798:  MOVLW  4E
0379A:  MOVWF  x71
0379C:  CLRF   x72
0379E:  MOVLW  05
037A0:  MOVWF  x77
037A2:  MOVLW  47
037A4:  MOVWF  x76
037A6:  MOVLW  05
037A8:  MOVWF  x79
037AA:  MOVLW  6F
037AC:  MOVWF  x78
037AE:  MOVLB  0
037B0:  CALL   1C14
037B4:  MOVF   01,F
037B6:  BNZ   37C0
.................... 			  { 
.................... 			  //fprintf(ttls0,"SIN MODE\r\n"); 
.................... 			  flagSin = true; 
037B8:  MOVLW  01
037BA:  MOVLB  3
037BC:  MOVWF  x44
037BE:  MOVLB  0
.................... 			  } 
.................... 			break; 
037C0:  BRA    37C2
....................  
.................... 	  } 
.................... 	 
.................... } 
037C2:  GOTO   3904 (RETURN)
....................  
....................  
.................... void getSubStr(void) 
.................... { 
.................... 	char c; 
.................... 	int8 i; 
....................  
.................... 	#ifdef DEBUG_INPUT 
.................... 	  fprintf(ttls0,"getSubStr(%i)\r\n",ndxPointer); 
.................... 	#endif 
....................  
.................... 	i = 0; 
*
01BAA:  MOVLB  5
01BAC:  CLRF   x66
.................... 	c = serStrBuffer_ttls0[ndxPointer]; 
01BAE:  CLRF   03
01BB0:  MOVF   x5B,W
01BB2:  ADDLW  45
01BB4:  MOVWF  FE9
01BB6:  MOVLW  04
01BB8:  ADDWFC 03,W
01BBA:  MOVWF  FEA
01BBC:  MOVFF  FEF,565
.................... 	while ( (c != 0x20) && (c != 0x00) ) 
.................... 	  { 
01BC0:  MOVF   x65,W
01BC2:  SUBLW  20
01BC4:  BZ    1C06
01BC6:  MOVF   x65,F
01BC8:  BZ    1C06
.................... 	  strParam[i] = c; 
01BCA:  CLRF   03
01BCC:  MOVF   x66,W
01BCE:  ADDLW  47
01BD0:  MOVWF  FE9
01BD2:  MOVLW  05
01BD4:  ADDWFC 03,W
01BD6:  MOVWF  FEA
01BD8:  MOVFF  565,FEF
.................... 	  strParam[i+1] = 0x00; 
01BDC:  MOVLW  01
01BDE:  ADDWF  x66,W
01BE0:  CLRF   03
01BE2:  ADDLW  47
01BE4:  MOVWF  FE9
01BE6:  MOVLW  05
01BE8:  ADDWFC 03,W
01BEA:  MOVWF  FEA
01BEC:  CLRF   FEF
.................... 	  i++; 
01BEE:  INCF   x66,F
.................... 	  ndxPointer++; 
01BF0:  INCF   x5B,F
.................... 	  c = serStrBuffer_ttls0[ndxPointer]; 
01BF2:  CLRF   03
01BF4:  MOVF   x5B,W
01BF6:  ADDLW  45
01BF8:  MOVWF  FE9
01BFA:  MOVLW  04
01BFC:  ADDWFC 03,W
01BFE:  MOVWF  FEA
01C00:  MOVFF  FEF,565
.................... 	  } 
01C04:  BRA    1BC0
.................... 	ndxPointer++; // point to chr after space 
01C06:  INCF   x5B,F
.................... 	if (c == 0x00) 
01C08:  MOVF   x65,F
01C0A:  BNZ   1C10
.................... 	  { 
.................... 	  flagFinished = true; 
01C0C:  MOVLW  01
01C0E:  MOVWF  x5C
.................... 	  } 
....................  
.................... } 
01C10:  MOVLB  0
01C12:  RETLW  00
....................  
....................  
....................  
.................... void parseInput(void) 
.................... { 
.................... 	unsigned int8 ttl; 
.................... 	#ifdef DEBUG_INPUT 
.................... 	  puts("parseInput()",ttls0); 
.................... 	#endif 
.................... 	serGetStr_ttls0();	// get string into buffer 
*
037C6:  GOTO   1B50
.................... 	ndxPointer = 0; 
037CA:  MOVLB  5
037CC:  CLRF   x5B
.................... 	flagSin = false;	// this is only valid once per line 
037CE:  MOVLB  3
037D0:  CLRF   x44
.................... 	flagFinished = false; 
037D2:  MOVLB  5
037D4:  CLRF   x5C
....................  
.................... 	#ifdef DEBUG_ECHO 
.................... 	  fprintf(ttls0,"parseInput(%s)\r\n",serStrBuffer_ttls0); 
.................... 	#endif 
.................... 	 
....................  
.................... 	// is it addressed to this device? 
.................... 	getSubStr();		// get the first substr 
037D6:  MOVLB  0
037D8:  CALL   1BAA
.................... 	if ( strcmp(strParam, DEVICE_ID) != CMP_EQ ) 
037DC:  MOVLW  05
037DE:  MOVWF  FEA
037E0:  MOVLW  5E
037E2:  MOVWF  FE9
037E4:  MOVLW  07
037E6:  MOVWF  01
037E8:  CLRF   FF7
037EA:  MOVLW  00
037EC:  CALL   00FE
037F0:  TBLRD*-
037F2:  TBLRD*+
037F4:  MOVFF  FF5,FEE
037F8:  DECFSZ 01,F
037FA:  BRA    37F2
037FC:  MOVLW  05
037FE:  MOVLB  5
03800:  MOVWF  x77
03802:  MOVLW  47
03804:  MOVWF  x76
03806:  MOVLW  05
03808:  MOVWF  x79
0380A:  MOVLW  5E
0380C:  MOVWF  x78
0380E:  MOVLB  0
03810:  CALL   1C14
03814:  MOVF   01,F
03816:  BZ    383C
.................... 	  { 
.................... 	  // since its not this device, send out buffer 
.................... 	  fprintf(ttls0,"%s\r\n",serStrBuffer_ttls0); 
03818:  MOVLW  04
0381A:  MOVWF  FEA
0381C:  MOVLW  45
0381E:  MOVWF  FE9
03820:  CALL   1C8C
03824:  MOVLW  0D
03826:  BTFSS  F9E.4
03828:  BRA    3826
0382A:  MOVWF  FAD
0382C:  MOVLW  0A
0382E:  BTFSS  F9E.4
03830:  BRA    382E
03832:  MOVWF  FAD
.................... 	  flagFinished = true; 
03834:  MOVLW  01
03836:  MOVLB  5
03838:  MOVWF  x5C
0383A:  MOVLB  0
.................... 	  } 
....................  
.................... 	// at this point, right device, right address? 
.................... 	getSubStr();		// get the first substr 
0383C:  CALL   1BAA
.................... 	if ( strcmp(strParam, "$1") != CMP_EQ ) 
03840:  MOVLW  24
03842:  MOVLB  5
03844:  MOVWF  x5E
03846:  MOVLW  31
03848:  MOVWF  x5F
0384A:  CLRF   x60
0384C:  MOVLW  05
0384E:  MOVWF  x77
03850:  MOVLW  47
03852:  MOVWF  x76
03854:  MOVLW  05
03856:  MOVWF  x79
03858:  MOVLW  5E
0385A:  MOVWF  x78
0385C:  MOVLB  0
0385E:  CALL   1C14
03862:  MOVF   01,F
03864:  BZ    38EC
.................... 	  { 
.................... 	  // not right address, so decriment address. 
.................... 	  strParam[0] = '0';	// replaces $ with 0, so $24 will read 025 
03866:  MOVLW  30
03868:  MOVLB  5
0386A:  MOVWF  x47
.................... 	  ttl = atoi(strParam) - 1; 
0386C:  MOVLW  05
0386E:  MOVWF  x66
03870:  MOVLW  47
03872:  MOVWF  x65
03874:  MOVLB  0
03876:  GOTO   1D02
0387A:  MOVLW  01
0387C:  SUBWF  01,W
0387E:  MOVLB  5
03880:  MOVWF  x5D
.................... 	  //send out device ID and new TTL address 
.................... 	  fprintf(ttls0,"%s ", DEVICE_ID); 
03882:  MOVLW  DC
03884:  MOVWF  FF6
03886:  MOVLW  01
03888:  MOVWF  FF7
0388A:  MOVLB  0
0388C:  GOTO   1EA6
03890:  MOVLW  20
03892:  BTFSS  F9E.4
03894:  BRA    3892
03896:  MOVWF  FAD
.................... 	  fprintf(ttls0,"$%ui", ttl); 
03898:  MOVLW  24
0389A:  BTFSS  F9E.4
0389C:  BRA    389A
0389E:  MOVWF  FAD
038A0:  MOVFF  55D,565
038A4:  MOVLW  1B
038A6:  MOVLB  5
038A8:  MOVWF  x66
038AA:  MOVLB  0
038AC:  GOTO   1EF6
038B0:  MOVLW  69
038B2:  BTFSS  F9E.4
038B4:  BRA    38B2
038B6:  MOVWF  FAD
.................... 	  // loop through and send out all paramaters on this command 
.................... 	  while (flagFinished == false) 
.................... 	    { 
038B8:  MOVLB  5
038BA:  MOVF   x5C,F
038BC:  BNZ   38DC
.................... 	    getSubStr();	// get the substr, each item is seperated by a space 
038BE:  MOVLB  0
038C0:  CALL   1BAA
.................... 	    fprintf(ttls0,"%s ",strParam); 
038C4:  MOVLW  05
038C6:  MOVWF  FEA
038C8:  MOVLW  47
038CA:  MOVWF  FE9
038CC:  CALL   1C8C
038D0:  MOVLW  20
038D2:  BTFSS  F9E.4
038D4:  BRA    38D2
038D6:  MOVWF  FAD
.................... 	    } 
038D8:  BRA    38B8
038DA:  MOVLB  5
.................... 	    fprintf(ttls0,"\r\n");	// end of command 
038DC:  MOVLW  0D
038DE:  BTFSS  F9E.4
038E0:  BRA    38DE
038E2:  MOVWF  FAD
038E4:  MOVLW  0A
038E6:  BTFSS  F9E.4
038E8:  BRA    38E6
038EA:  MOVWF  FAD
.................... 	  } 
.................... 	 
....................  
....................  
.................... 	modalTime = 0; 
038EC:  MOVLB  3
038EE:  CLRF   x42
038F0:  CLRF   x41
.................... 	modalServo  = 0; 
038F2:  CLRF   x40
.................... 	while (flagFinished == false) 
.................... 	  { 
038F4:  MOVLB  5
038F6:  MOVF   x5C,F
038F8:  BNZ   390A
.................... 	  getSubStr();		// get the substr, each item is seperated by a space 
038FA:  MOVLB  0
038FC:  CALL   1BAA
.................... 	  parseSubStr();	// parse the substr 
03900:  GOTO   2CFC
.................... 	  } 
03904:  MOVLB  3
03906:  BRA    38F4
03908:  MOVLB  5
.................... } 
0390A:  MOVLB  0
0390C:  GOTO   391A (RETURN)
....................  
....................  
.................... void procInput(void) 
.................... { 
.................... 	#ifdef DEBUG_INPUT 
.................... 	  //puts("procInput()",ttls0); 
.................... 	#endif 
.................... 	if (serIsStrReady_ttls0() == true) { 
03910:  GOTO   1AB6
03914:  DECFSZ 01,W
03916:  BRA    391A
.................... 	  parseInput(); 
03918:  BRA    37C6
.................... 	  } 
....................  
.................... } 
0391A:  GOTO   3C92 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "frame.c" 
.................... /* 
....................           file: frame.c 
....................        project: SSX32  
....................    description: outputs the servo frame 
.................... 				starts all outputs at once, and turns off at end of each pw, 
.................... 				this will actualy stager the motor start slightly from one another, 
.................... 				and allows for driving 32 servos in a single frame [of time] 
....................     
....................    Changelog: 
.................... 	  02/03/11 Split frame into groups, having issues with timming 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
....................  
....................  
....................  
.................... void outputGroup(int8 s, int8 e) 
.................... { 
.................... 	int8 i; 
.................... 	int8 ndx; 
....................  
.................... 	set_timer0(0);	// set the pw timer to 0 
*
01920:  CLRF   FD7
01922:  CLRF   FD6
.................... 	 
.................... 	for (i=s;i<=e;i++) 
01924:  MOVFF  55D,55F
01928:  MOVLB  5
0192A:  MOVF   x5F,W
0192C:  SUBWF  x5E,W
0192E:  BNC   1988
.................... 	  { 
.................... 	  ndx = sorted[i]; 
01930:  CLRF   03
01932:  MOVF   x5F,W
01934:  ADDLW  20
01936:  MOVWF  FE9
01938:  MOVLW  03
0193A:  ADDWFC 03,W
0193C:  MOVWF  FEA
0193E:  MOVFF  FEF,560
.................... 	  mOutputSXHigh(ndx); 
01942:  BCF    FD8.0
01944:  RLCF   x60,W
01946:  CLRF   03
01948:  MOVLB  0
0194A:  CALL   00AE
0194E:  TBLRD*+
01950:  MOVFF  FF5,03
01954:  MOVLB  5
01956:  MOVWF  x61
01958:  MOVFF  03,562
0195C:  MOVWF  x63
0195E:  MOVLW  01
01960:  MOVWF  x64
01962:  MOVLW  0F
01964:  MOVWF  x66
01966:  MOVLW  89
01968:  MOVWF  x65
0196A:  MOVLB  0
0196C:  RCALL  18DE
0196E:  MOVFF  561,563
01972:  MOVLB  5
01974:  CLRF   x64
01976:  MOVLW  0F
01978:  MOVWF  x66
0197A:  MOVLW  92
0197C:  MOVWF  x65
0197E:  MOVLB  0
01980:  RCALL  18DE
.................... 	  } 
01982:  MOVLB  5
01984:  INCF   x5F,F
01986:  BRA    192A
....................  
.................... 	  // here we follow our sorted index for the order of the servos 
.................... 	for (i=s;i<=e;i++) 
01988:  MOVFF  55D,55F
0198C:  MOVF   x5F,W
0198E:  SUBWF  x5E,W
01990:  BNC   1A40
.................... 	  { 
.................... 	  ndx = sorted[i]; 
01992:  CLRF   03
01994:  MOVF   x5F,W
01996:  ADDLW  20
01998:  MOVWF  FE9
0199A:  MOVLW  03
0199C:  ADDWFC 03,W
0199E:  MOVWF  FEA
019A0:  MOVFF  FEF,560
.................... 	  while( get_timer0() < servo[ndx].timeout );  // just wait for this period, notice the ; at the end 
019A4:  MOVF   FD6,W
019A6:  MOVFF  FD7,03
019AA:  MOVWF  x61
019AC:  MOVFF  FD7,562
019B0:  CLRF   x79
019B2:  MOVFF  560,578
019B6:  CLRF   x7B
019B8:  MOVLW  18
019BA:  MOVWF  x7A
019BC:  MOVLB  0
019BE:  CALL   0492
019C2:  MOVFF  02,564
019C6:  MOVFF  01,563
019CA:  MOVLW  16
019CC:  MOVLB  5
019CE:  ADDWF  01,W
019D0:  MOVWF  01
019D2:  MOVLW  00
019D4:  ADDWFC 02,W
019D6:  MOVWF  03
019D8:  MOVF   01,W
019DA:  ADDLW  20
019DC:  MOVWF  FE9
019DE:  MOVLW  00
019E0:  ADDWFC 03,W
019E2:  MOVWF  FEA
019E4:  MOVFF  FEC,03
019E8:  MOVF   FED,F
019EA:  MOVFF  FEF,01
019EE:  MOVF   x62,W
019F0:  SUBWF  03,W
019F2:  BNC   19FC
019F4:  BNZ   19A4
019F6:  MOVF   01,W
019F8:  SUBWF  x61,W
019FA:  BNC   19A4
.................... 	  mOutputSXLow(ndx); 
019FC:  BCF    FD8.0
019FE:  RLCF   x60,W
01A00:  CLRF   03
01A02:  MOVLB  0
01A04:  CALL   00AE
01A08:  TBLRD*+
01A0A:  MOVFF  FF5,03
01A0E:  MOVLB  5
01A10:  MOVWF  x61
01A12:  MOVFF  03,562
01A16:  MOVWF  x63
01A18:  CLRF   x64
01A1A:  MOVLW  0F
01A1C:  MOVWF  x66
01A1E:  MOVLW  89
01A20:  MOVWF  x65
01A22:  MOVLB  0
01A24:  RCALL  18DE
01A26:  MOVFF  561,563
01A2A:  MOVLB  5
01A2C:  CLRF   x64
01A2E:  MOVLW  0F
01A30:  MOVWF  x66
01A32:  MOVLW  92
01A34:  MOVWF  x65
01A36:  MOVLB  0
01A38:  RCALL  18DE
.................... 	  }	   
01A3A:  MOVLB  5
01A3C:  INCF   x5F,F
01A3E:  BRA    198C
.................... 	   
.................... } 
01A40:  MOVLB  0
01A42:  RETLW  00
....................  
....................  
....................  
.................... // This is a little sad looking, but I had to output in groups of 4 servos 
.................... // this is used to allow servos to come on at different times, and 
.................... // to tell you the truth, I was having a hard time with later pw servos 
.................... // waiting for others to turn off. 
.................... void outputFrame(void) 
.................... { 
.................... 	outputGroup(0,3); 
01A44:  MOVLB  5
01A46:  CLRF   x5D
01A48:  MOVLW  03
01A4A:  MOVWF  x5E
01A4C:  MOVLB  0
01A4E:  RCALL  1920
.................... 	outputGroup(4,7); 
01A50:  MOVLW  04
01A52:  MOVLB  5
01A54:  MOVWF  x5D
01A56:  MOVLW  07
01A58:  MOVWF  x5E
01A5A:  MOVLB  0
01A5C:  RCALL  1920
.................... 	outputGroup(8,11); 
01A5E:  MOVLW  08
01A60:  MOVLB  5
01A62:  MOVWF  x5D
01A64:  MOVLW  0B
01A66:  MOVWF  x5E
01A68:  MOVLB  0
01A6A:  RCALL  1920
.................... 	outputGroup(12,15); 
01A6C:  MOVLW  0C
01A6E:  MOVLB  5
01A70:  MOVWF  x5D
01A72:  MOVLW  0F
01A74:  MOVWF  x5E
01A76:  MOVLB  0
01A78:  RCALL  1920
.................... 	outputGroup(16,19); 
01A7A:  MOVLW  10
01A7C:  MOVLB  5
01A7E:  MOVWF  x5D
01A80:  MOVLW  13
01A82:  MOVWF  x5E
01A84:  MOVLB  0
01A86:  RCALL  1920
.................... 	outputGroup(20,23); 
01A88:  MOVLW  14
01A8A:  MOVLB  5
01A8C:  MOVWF  x5D
01A8E:  MOVLW  17
01A90:  MOVWF  x5E
01A92:  MOVLB  0
01A94:  RCALL  1920
.................... 	outputGroup(24,27); 
01A96:  MOVLW  18
01A98:  MOVLB  5
01A9A:  MOVWF  x5D
01A9C:  MOVLW  1B
01A9E:  MOVWF  x5E
01AA0:  MOVLB  0
01AA2:  RCALL  1920
.................... 	outputGroup(28,31); 
01AA4:  MOVLW  1C
01AA6:  MOVLB  5
01AA8:  MOVWF  x5D
01AAA:  MOVLW  1F
01AAC:  MOVWF  x5E
01AAE:  MOVLB  0
01AB0:  RCALL  1920
.................... } 
01AB2:  GOTO   3C8E (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... #include "boot.c" 
.................... /* 
....................           file: boot.c 
....................        project: SSX32  
....................    description: bootup code 
....................  
....................    Changelog: 
....................       01/15/11 This file created 
....................  
....................  
.................... */ 
....................  
....................  
.................... void boot(void) 
.................... { 
.................... 	int8 i; 
....................  
.................... 	#ifdef DEBUG_MSG 
.................... 	  puts("Boot",debug); 
.................... 	#endif 
.................... 	 
.................... 	setup_adc_ports(NO_ANALOGS|VSS_VDD); 
*
005B0:  MOVLW  00
005B2:  MOVWF  F7E
005B4:  BCF    FC1.4
005B6:  BCF    FC1.5
005B8:  MOVF   F7F,W
005BA:  ANDLW  E0
005BC:  MOVWF  F7F
.................... 	setup_adc(ADC_CLOCK_DIV_2|ADC_TAD_MUL_0); 
005BE:  MOVF   FC0,W
005C0:  ANDLW  C0
005C2:  MOVWF  FC0
005C4:  BCF    FC0.7
005C6:  BSF    FC2.0
.................... 	//setup_psp(PSP_DISABLED);	pic18f46k20 only 
.................... 	setup_spi(SPI_SS_DISABLED); 
005C8:  BCF    FC6.5
005CA:  BCF    F94.5
005CC:  BSF    F94.4
005CE:  BCF    F94.3
005D0:  MOVLW  01
005D2:  MOVWF  FC6
005D4:  MOVLW  00
005D6:  MOVWF  FC7
.................... 	setup_wdt(WDT_OFF); 
005D8:  BCF    FD1.0
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_16);	// set for 1uSec resolution 
005DA:  MOVLW  83
005DC:  MOVWF  FD5
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); // note, 2x resolution .5uSec 
005DE:  MOVLW  B5
005E0:  MOVWF  FCD
.................... 	setup_timer_2(T2_DISABLED,0,1); 
005E2:  MOVLW  00
005E4:  MOVWF  FCA
005E6:  MOVLW  00
005E8:  MOVWF  FCB
.................... 	setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
005EA:  CLRF   FB1
.................... 	setup_ccp1(CCP_OFF); 
005EC:  BSF    F94.2
005EE:  CLRF   FBD
005F0:  CLRF   FB7
005F2:  CLRF   FB6
005F4:  MOVLW  01
005F6:  MOVWF  FB9
.................... 	setup_comparator(NC_NC_NC_NC); 
005F8:  BCF    F79.5
005FA:  BCF    F79.4
005FC:  MOVLW  04
005FE:  MOVWF  F7A
00600:  MOVWF  F7B
.................... 	//setup_oscillator(OSC_16MHZ|OSC_INTRC|OSC_PLL_ON); // defunc, replaced by #use delay(clock=xx) 
....................   
....................   
.................... 	mLED(PW_LED,ON); 
00602:  BSF    F8B.5
00604:  BCF    F94.5
....................  
.................... 	firstUse();	// check if first use, and do stuff if it is 
00606:  BRA    046A
....................  
.................... 	// set some defaults all all servos 
.................... 	mServoLoop 
00608:  MOVLB  5
0060A:  CLRF   x5D
0060C:  MOVF   x5D,W
0060E:  SUBLW  1F
00610:  BTFSS  FD8.0
00612:  BRA    09D2
.................... 	  { 
.................... 	  servo[i].mode = MODE_OFF; 
00614:  CLRF   x79
00616:  MOVFF  55D,578
0061A:  CLRF   x7B
0061C:  MOVLW  18
0061E:  MOVWF  x7A
00620:  MOVLB  0
00622:  RCALL  0492
00624:  MOVLW  20
00626:  MOVLB  5
00628:  ADDWF  01,W
0062A:  MOVWF  FE9
0062C:  MOVLW  00
0062E:  ADDWFC 02,W
00630:  MOVWF  FEA
00632:  CLRF   FEF
.................... 	  servo[i].pwCurrent = PW_CENTER; 
00634:  CLRF   x79
00636:  MOVFF  55D,578
0063A:  CLRF   x7B
0063C:  MOVLW  18
0063E:  MOVWF  x7A
00640:  MOVLB  0
00642:  RCALL  0492
00644:  MOVFF  01,55E
00648:  MOVLW  01
0064A:  MOVLB  5
0064C:  ADDWF  01,W
0064E:  MOVWF  01
00650:  MOVLW  00
00652:  ADDWFC 02,W
00654:  MOVWF  03
00656:  MOVF   01,W
00658:  ADDLW  20
0065A:  MOVWF  FE9
0065C:  MOVLW  00
0065E:  ADDWFC 03,W
00660:  MOVWF  FEA
00662:  MOVLW  05
00664:  MOVWF  FEC
00666:  MOVF   FED,F
00668:  MOVLW  DC
0066A:  MOVWF  FEF
.................... 	  servo[i].pwDestination = PW_CENTER; 
0066C:  CLRF   x79
0066E:  MOVFF  55D,578
00672:  CLRF   x7B
00674:  MOVLW  18
00676:  MOVWF  x7A
00678:  MOVLB  0
0067A:  RCALL  0492
0067C:  MOVFF  01,55E
00680:  MOVLW  03
00682:  MOVLB  5
00684:  ADDWF  01,W
00686:  MOVWF  01
00688:  MOVLW  00
0068A:  ADDWFC 02,W
0068C:  MOVWF  03
0068E:  MOVF   01,W
00690:  ADDLW  20
00692:  MOVWF  FE9
00694:  MOVLW  00
00696:  ADDWFC 03,W
00698:  MOVWF  FEA
0069A:  MOVLW  05
0069C:  MOVWF  FEC
0069E:  MOVF   FED,F
006A0:  MOVLW  DC
006A2:  MOVWF  FEF
.................... 	  servo[i].step = 0; 
006A4:  CLRF   x79
006A6:  MOVFF  55D,578
006AA:  CLRF   x7B
006AC:  MOVLW  18
006AE:  MOVWF  x7A
006B0:  MOVLB  0
006B2:  RCALL  0492
006B4:  MOVFF  01,55E
006B8:  MOVLW  05
006BA:  MOVLB  5
006BC:  ADDWF  01,W
006BE:  MOVWF  01
006C0:  MOVLW  00
006C2:  ADDWFC 02,W
006C4:  MOVWF  03
006C6:  MOVF   01,W
006C8:  ADDLW  20
006CA:  MOVWF  FE9
006CC:  MOVLW  00
006CE:  ADDWFC 03,W
006D0:  MOVWF  FEA
006D2:  CLRF   FEC
006D4:  MOVF   FED,F
006D6:  CLRF   FEF
.................... 	  servo[i].decel = false; 
006D8:  CLRF   x79
006DA:  MOVFF  55D,578
006DE:  CLRF   x7B
006E0:  MOVLW  18
006E2:  MOVWF  x7A
006E4:  MOVLB  0
006E6:  RCALL  0492
006E8:  MOVFF  01,55E
006EC:  MOVLW  07
006EE:  MOVLB  5
006F0:  ADDWF  01,W
006F2:  MOVWF  01
006F4:  MOVLW  00
006F6:  ADDWFC 02,W
006F8:  MOVWF  03
006FA:  MOVF   01,W
006FC:  ADDLW  20
006FE:  MOVWF  FE9
00700:  MOVLW  00
00702:  ADDWFC 03,W
00704:  MOVWF  FEA
00706:  CLRF   FEF
.................... 	  servo[i].offset = ee_readOffsetPW(i); 
00708:  CLRF   x79
0070A:  MOVFF  55D,578
0070E:  CLRF   x7B
00710:  MOVLW  18
00712:  MOVWF  x7A
00714:  MOVLB  0
00716:  RCALL  0492
00718:  MOVFF  01,55E
0071C:  MOVLW  08
0071E:  MOVLB  5
00720:  ADDWF  01,W
00722:  MOVWF  01
00724:  MOVLW  00
00726:  ADDWFC 02,W
00728:  MOVWF  03
0072A:  MOVF   01,W
0072C:  ADDLW  20
0072E:  MOVWF  01
00730:  MOVLW  00
00732:  ADDWFC 03,F
00734:  MOVFF  01,55E
00738:  MOVFF  03,55F
0073C:  MOVFF  55D,560
00740:  MOVLB  0
00742:  BRA    04B4
00744:  MOVFF  55F,FEA
00748:  MOVFF  55E,FE9
0074C:  MOVFF  02,FEC
00750:  MOVF   FED,F
00752:  MOVFF  01,FEF
.................... 	  servo[i].home = ee_readHomePW(i); 
00756:  MOVLB  5
00758:  CLRF   x79
0075A:  MOVFF  55D,578
0075E:  CLRF   x7B
00760:  MOVLW  18
00762:  MOVWF  x7A
00764:  MOVLB  0
00766:  RCALL  0492
00768:  MOVFF  01,55E
0076C:  MOVLW  0A
0076E:  MOVLB  5
00770:  ADDWF  01,W
00772:  MOVWF  01
00774:  MOVLW  00
00776:  ADDWFC 02,W
00778:  MOVWF  03
0077A:  MOVF   01,W
0077C:  ADDLW  20
0077E:  MOVWF  01
00780:  MOVLW  00
00782:  ADDWFC 03,F
00784:  MOVFF  01,55E
00788:  MOVFF  03,55F
0078C:  MOVFF  55D,560
00790:  MOVLB  0
00792:  BRA    0532
00794:  MOVFF  55F,FEA
00798:  MOVFF  55E,FE9
0079C:  MOVFF  02,FEC
007A0:  MOVF   FED,F
007A2:  MOVFF  01,FEF
.................... 	  servo[i].min = 800; 
007A6:  MOVLB  5
007A8:  CLRF   x79
007AA:  MOVFF  55D,578
007AE:  CLRF   x7B
007B0:  MOVLW  18
007B2:  MOVWF  x7A
007B4:  MOVLB  0
007B6:  RCALL  0492
007B8:  MOVFF  01,55E
007BC:  MOVLW  0C
007BE:  MOVLB  5
007C0:  ADDWF  01,W
007C2:  MOVWF  01
007C4:  MOVLW  00
007C6:  ADDWFC 02,W
007C8:  MOVWF  03
007CA:  MOVF   01,W
007CC:  ADDLW  20
007CE:  MOVWF  FE9
007D0:  MOVLW  00
007D2:  ADDWFC 03,W
007D4:  MOVWF  FEA
007D6:  MOVLW  03
007D8:  MOVWF  FEC
007DA:  MOVF   FED,F
007DC:  MOVLW  20
007DE:  MOVWF  FEF
.................... 	  servo[i].max = 2200; 
007E0:  CLRF   x79
007E2:  MOVFF  55D,578
007E6:  CLRF   x7B
007E8:  MOVLW  18
007EA:  MOVWF  x7A
007EC:  MOVLB  0
007EE:  RCALL  0492
007F0:  MOVFF  01,55E
007F4:  MOVLW  0E
007F6:  MOVLB  5
007F8:  ADDWF  01,W
007FA:  MOVWF  01
007FC:  MOVLW  00
007FE:  ADDWFC 02,W
00800:  MOVWF  03
00802:  MOVF   01,W
00804:  ADDLW  20
00806:  MOVWF  FE9
00808:  MOVLW  00
0080A:  ADDWFC 03,W
0080C:  MOVWF  FEA
0080E:  MOVLW  08
00810:  MOVWF  FEC
00812:  MOVF   FED,F
00814:  MOVLW  98
00816:  MOVWF  FEF
.................... 	  servo[i].writeOffset = false; 
00818:  CLRF   x79
0081A:  MOVFF  55D,578
0081E:  CLRF   x7B
00820:  MOVLW  18
00822:  MOVWF  x7A
00824:  MOVLB  0
00826:  RCALL  0492
00828:  MOVFF  01,55E
0082C:  MOVLW  10
0082E:  MOVLB  5
00830:  ADDWF  01,W
00832:  MOVWF  01
00834:  MOVLW  00
00836:  ADDWFC 02,W
00838:  MOVWF  03
0083A:  MOVF   01,W
0083C:  ADDLW  20
0083E:  MOVWF  FE9
00840:  MOVLW  00
00842:  ADDWFC 03,W
00844:  MOVWF  FEA
00846:  CLRF   FEF
.................... 	  servo[i].writeHome = false; 
00848:  CLRF   x79
0084A:  MOVFF  55D,578
0084E:  CLRF   x7B
00850:  MOVLW  18
00852:  MOVWF  x7A
00854:  MOVLB  0
00856:  RCALL  0492
00858:  MOVFF  01,55E
0085C:  MOVLW  11
0085E:  MOVLB  5
00860:  ADDWF  01,W
00862:  MOVWF  01
00864:  MOVLW  00
00866:  ADDWFC 02,W
00868:  MOVWF  03
0086A:  MOVF   01,W
0086C:  ADDLW  20
0086E:  MOVWF  FE9
00870:  MOVLW  00
00872:  ADDWFC 03,W
00874:  MOVWF  FEA
00876:  CLRF   FEF
.................... 	  servo[i].writeMin = false; 
00878:  CLRF   x79
0087A:  MOVFF  55D,578
0087E:  CLRF   x7B
00880:  MOVLW  18
00882:  MOVWF  x7A
00884:  MOVLB  0
00886:  RCALL  0492
00888:  MOVFF  01,55E
0088C:  MOVLW  12
0088E:  MOVLB  5
00890:  ADDWF  01,W
00892:  MOVWF  01
00894:  MOVLW  00
00896:  ADDWFC 02,W
00898:  MOVWF  03
0089A:  MOVF   01,W
0089C:  ADDLW  20
0089E:  MOVWF  FE9
008A0:  MOVLW  00
008A2:  ADDWFC 03,W
008A4:  MOVWF  FEA
008A6:  CLRF   FEF
.................... 	  servo[i].writeMax = false; 
008A8:  CLRF   x79
008AA:  MOVFF  55D,578
008AE:  CLRF   x7B
008B0:  MOVLW  18
008B2:  MOVWF  x7A
008B4:  MOVLB  0
008B6:  RCALL  0492
008B8:  MOVFF  01,55E
008BC:  MOVLW  13
008BE:  MOVLB  5
008C0:  ADDWF  01,W
008C2:  MOVWF  01
008C4:  MOVLW  00
008C6:  ADDWFC 02,W
008C8:  MOVWF  03
008CA:  MOVF   01,W
008CC:  ADDLW  20
008CE:  MOVWF  FE9
008D0:  MOVLW  00
008D2:  ADDWFC 03,W
008D4:  MOVWF  FEA
008D6:  CLRF   FEF
.................... 	  servo[i].master = 0; 
008D8:  CLRF   x79
008DA:  MOVFF  55D,578
008DE:  CLRF   x7B
008E0:  MOVLW  18
008E2:  MOVWF  x7A
008E4:  MOVLB  0
008E6:  RCALL  0492
008E8:  MOVFF  01,55E
008EC:  MOVLW  14
008EE:  MOVLB  5
008F0:  ADDWF  01,W
008F2:  MOVWF  01
008F4:  MOVLW  00
008F6:  ADDWFC 02,W
008F8:  MOVWF  03
008FA:  MOVF   01,W
008FC:  ADDLW  20
008FE:  MOVWF  FE9
00900:  MOVLW  00
00902:  ADDWFC 03,W
00904:  MOVWF  FEA
00906:  CLRF   FEF
.................... 	  servo[i].discrete = 0; 
00908:  CLRF   x79
0090A:  MOVFF  55D,578
0090E:  CLRF   x7B
00910:  MOVLW  18
00912:  MOVWF  x7A
00914:  MOVLB  0
00916:  RCALL  0492
00918:  MOVFF  01,55E
0091C:  MOVLW  15
0091E:  MOVLB  5
00920:  ADDWF  01,W
00922:  MOVWF  01
00924:  MOVLW  00
00926:  ADDWFC 02,W
00928:  MOVWF  03
0092A:  MOVF   01,W
0092C:  ADDLW  20
0092E:  MOVWF  FE9
00930:  MOVLW  00
00932:  ADDWFC 03,W
00934:  MOVWF  FEA
00936:  CLRF   FEF
.................... 	  servo[i].timeOut = 0; 
00938:  CLRF   x79
0093A:  MOVFF  55D,578
0093E:  CLRF   x7B
00940:  MOVLW  18
00942:  MOVWF  x7A
00944:  MOVLB  0
00946:  RCALL  0492
00948:  MOVFF  01,55E
0094C:  MOVLW  16
0094E:  MOVLB  5
00950:  ADDWF  01,W
00952:  MOVWF  01
00954:  MOVLW  00
00956:  ADDWFC 02,W
00958:  MOVWF  03
0095A:  MOVF   01,W
0095C:  ADDLW  20
0095E:  MOVWF  FE9
00960:  MOVLW  00
00962:  ADDWFC 03,W
00964:  MOVWF  FEA
00966:  CLRF   FEC
00968:  MOVF   FED,F
0096A:  CLRF   FEF
.................... 	   
.................... 	  if (servo[i].home != 0) 
0096C:  CLRF   x79
0096E:  MOVFF  55D,578
00972:  CLRF   x7B
00974:  MOVLW  18
00976:  MOVWF  x7A
00978:  MOVLB  0
0097A:  RCALL  0492
0097C:  MOVFF  01,55E
00980:  MOVLW  0A
00982:  MOVLB  5
00984:  ADDWF  01,W
00986:  MOVWF  01
00988:  MOVLW  00
0098A:  ADDWFC 02,W
0098C:  MOVWF  03
0098E:  MOVF   01,W
00990:  ADDLW  20
00992:  MOVWF  FE9
00994:  MOVLW  00
00996:  ADDWFC 03,W
00998:  MOVWF  FEA
0099A:  MOVFF  FEC,55F
0099E:  MOVF   FED,F
009A0:  MOVFF  FEF,55E
009A4:  MOVF   x5E,F
009A6:  BNZ   09AC
009A8:  MOVF   x5F,F
009AA:  BZ    09CE
.................... 	    { 
.................... 		servo[i].mode = MODE_NORMAL; 
009AC:  CLRF   x79
009AE:  MOVFF  55D,578
009B2:  CLRF   x7B
009B4:  MOVLW  18
009B6:  MOVWF  x7A
009B8:  MOVLB  0
009BA:  RCALL  0492
009BC:  MOVLW  20
009BE:  MOVLB  5
009C0:  ADDWF  01,W
009C2:  MOVWF  FE9
009C4:  MOVLW  00
009C6:  ADDWFC 02,W
009C8:  MOVWF  FEA
009CA:  MOVLW  01
009CC:  MOVWF  FEF
.................... 		} 
.................... 	  } 
009CE:  INCF   x5D,F
009D0:  BRA    060C
....................   
....................   
.................... 	flagAllOff = true; 
009D2:  MOVLW  01
009D4:  MOVLB  3
009D6:  MOVWF  x43
.................... 	 
.................... 	//setup_uart(9600, ttls0); 
.................... 	setup_uart(19200, ttls0); 
009D8:  BSF    FB8.3
009DA:  MOVLW  40
009DC:  MOVWF  FAF
009DE:  MOVLW  03
009E0:  MOVWF  FB0
009E2:  MOVLW  A6
009E4:  MOVWF  FAC
.................... 	//setup_uart(38400, ttls0); 
.................... 	serFlushFifo_ttls0();		// flush/ini the serial drivers 
009E6:  MOVLB  0
009E8:  CALL   0116
....................  
.................... 	enable_interrupts(INT_RDA); 
009EC:  BSF    F9D.5
.................... 	enable_interrupts(GLOBAL); 
009EE:  MOVLW  C0
009F0:  IORWF  FF2,F
....................   
....................  } 
009F2:  GOTO   3C5C (RETURN)
....................  
....................  
.................... #ifdef DEBUG_PRESET 
....................   #include "servo-test.c" 
....................   #endif 
....................  
.................... void main() 
.................... { 
*
03C14:  CLRF   FF8
03C16:  BCF    FD0.7
03C18:  BSF    07.7
03C1A:  CLRF   FEA
03C1C:  CLRF   FE9
03C1E:  MOVLW  70
03C20:  MOVWF  FD3
03C22:  MOVLW  40
03C24:  MOVWF  F9B
03C26:  MOVF   FD3,W
03C28:  BSF    FB8.3
03C2A:  MOVLW  82
03C2C:  MOVWF  FAF
03C2E:  MOVLW  06
03C30:  MOVWF  FB0
03C32:  MOVLW  A6
03C34:  MOVWF  FAC
03C36:  MOVLW  90
03C38:  MOVWF  FAB
03C3A:  BCF    F93.7
03C3C:  BSF    F8A.7
03C3E:  MOVLW  00
03C40:  MOVWF  F7E
03C42:  BCF    FC1.4
03C44:  BCF    FC1.5
03C46:  MOVF   F7F,W
03C48:  ANDLW  E0
03C4A:  MOVWF  F7F
03C4C:  BCF    F79.5
03C4E:  BCF    F79.4
03C50:  CLRF   F7A
03C52:  CLRF   F7B
03C54:  CLRF   1A
03C56:  CLRF   1B
.................... 	#ifdef DEBUG_FRAMES 
.................... 	  int8 frameCount; 
.................... 	  frameCount = 0; 
.................... 	  #endif 
....................  
.................... 	//delay_ms(2000); // used durring debugging 
.................... 	boot(); 
03C58:  GOTO   05B0
....................  
.................... 	#ifdef DEBUG_PRESET 
.................... 	  sevoTest(); 
.................... 	  #endif 
....................  
.................... 	#ifdef DEBUG_MSG 
.................... 	  puts("Entering loop",debug); 
.................... 	  #endif 
.................... 	   
.................... 	mForever 
....................       { 
.................... 	  if (flagAllOff == false) 
03C5C:  MOVLB  3
03C5E:  MOVF   x43,F
03C60:  BNZ   3C8E
.................... 	    { 
.................... 	    servoCalcTimeOuts();		// calc the timeouts for each servo 
03C62:  MOVLB  0
03C64:  GOTO   1168
.................... 	    servoSort();				// sort the timeout order 
03C68:  GOTO   17A0
.................... 	    mWaitFrame;					// wait for end of prior frame 
03C6C:  MOVF   FCE,W
03C6E:  MOVFF  FCF,03
03C72:  MOVLB  5
03C74:  MOVWF  x5D
03C76:  MOVF   FCF,W
03C78:  MOVWF  x5E
03C7A:  SUBLW  7C
03C7C:  BTFSS  FD8.0
03C7E:  BRA    3C84
03C80:  MOVLB  0
03C82:  BRA    3C6C
.................... 	    mBeginFrame;				// start of frame 
03C84:  CLRF   FCF
03C86:  CLRF   FCE
.................... 	    outputFrame();				// output the frame 
03C88:  MOVLB  0
03C8A:  GOTO   1A44
.................... 		#ifdef DEBUG_FRAMES 
.................... 	      frameCount++; 
.................... 		  if (frameCount == 10) { for(;;); } // stop if we hit 4 frames 
.................... 	      #endif 
.................... 		} 
.................... 	  procInput();					// process any input that may have come in 
03C8E:  MOVLB  0
03C90:  BRA    3910
.................... 	  ee_writeServoData();			// we write servo data to eeprom outside of a frame 
03C92:  BRA    391E
....................       } 
03C94:  BRA    3C5C
....................  
....................  
.................... } 
03C96:  SLEEP 

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV20 NOWDT WDT128
   Word  3: 0D00   CCP2C1 NOPBADEN LPT1OSC NODELAYINTOSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
